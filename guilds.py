"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ ğŸŒ¸ SUNSHINE PARADISE â€” GUILDS + ECONOMY v5.0 ğŸŒ¸                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ² main.py:                                               â•‘
â•‘   from guilds import setup                                           â•‘
â•‘   setup(bot)                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

v5.0 - IDEAL ECONOMY:
  âœ¨ ĞĞĞ’ĞĞ•: Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ„ĞµÑ€Ğ¼ (Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ°)
  âœ¨ ĞĞĞ’ĞĞ•: ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑĞ¾Ğ²
  âœ¨ ĞĞĞ’ĞĞ•: Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ¸ Ğ¸Ğ· economy.py
  âœ¨ ĞĞĞ’ĞĞ•: ĞŸĞ°ÑÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ‡Ğ°Ñ
  âœ¨ ĞĞĞ’ĞĞ•: ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ´Ğ»Ñ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºĞ¸ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ¼Ğ°Ğ¼Ğ¸
  âœ¨ ĞĞĞ’ĞĞ•: Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ¸
  âœ¨ Ğ£Ğ›Ğ£Ğ§Ğ¨Ğ•ĞĞ: ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ»ĞµĞ¹Ñ‚ĞµĞ½Ğ°Ğ½Ñ‚Ğ¾Ğ² Ğ¸ Ğ·Ğ°Ğ¼Ğ¾Ğ² Ğ² !ginfo
  âœ¨ Ğ£Ğ›Ğ£Ğ§Ğ¨Ğ•ĞĞ: ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ñ„Ğ»Ğ¸Ğ±ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑĞ° (!, ! )
"""

import disnake
from disnake.ext import commands, tasks
import asyncio
import random
import uuid
import io
from datetime import datetime, timedelta
from typing import Optional, List, Tuple, Dict
from pymongo import MongoClient
from dotenv import load_dotenv
import os

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºÑƒ
try:
    from economy import (
        INCOME_SOURCES, GUILD_INCOME_UPGRADES, INCOME_TIERS,
        get_income_per_hour, get_guild_vault_bonus, format_income_sources,
        calculate_farm_payback_days, get_income_sources_by_tier
    )
except ImportError:
    print("âš ï¸ economy.py Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ - Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹")
    INCOME_SOURCES = {}
    GUILD_INCOME_UPGRADES = {}
    INCOME_TIERS = {}
    
    # Fallback Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    def get_income_per_hour(farms, upgrades=None):
        return 0
    def get_guild_vault_bonus(upgrades=None):
        return 1.0
    def format_income_sources(farms, tier=None):
        return "> â€”\n"
    def calculate_farm_payback_days(farm_key):
        return 0
    def get_income_sources_by_tier(tier):
        return {}

load_dotenv()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ—„ï¸ MONGODB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MONGO_URI = os.getenv("MONGODB_URI", "mongodb+srv://user:pass@cluster.mongodb.net/sunshine")
DB_NAME = os.getenv("MONGO_DB_NAME", "")  # Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ ÑĞ²Ğ½Ğ¾ Ñ‡ĞµÑ€ĞµĞ· env
mongo_client = None
db = None


def _extract_db_name(uri: str) -> str:
    """Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµÑ‚ Ğ¸Ğ¼Ñ Ğ‘Ğ” Ğ¸Ğ· URI. Fallback: 'sunshine'."""
    try:
        # URI Ğ²Ğ¸Ğ´Ğ°: ...cluster.net/dbname?params
        path = uri.split("?")[0]  # ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ query params
        name = path.rsplit("/", 1)[-1]  # Ğ±ĞµÑ€Ñ‘Ğ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚ Ğ¿ÑƒÑ‚Ğ¸
        if name and name not in ("", "admin", "local", "config"):
            return name
    except Exception:
        pass
    return "sunshine"


def init_db():
    global mongo_client, db
    try:
        mongo_client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        # Ğ¯Ğ²Ğ½Ğ¾ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¸Ğ¼Ñ Ğ‘Ğ” â€” get_database() Ğ±ĞµĞ· Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ ĞµÑĞ»Ğ¸ URI Ğ±ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸
        db_name = DB_NAME or _extract_db_name(MONGO_URI)
        db = mongo_client[db_name]
        db.command("ping")
        print("âœ… MongoDB Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾")
        db["users"].create_index([("server_id", 1), ("user_id", 1)], unique=True)
        db["guilds"].create_index([("server_id", 1), ("id", 1)], unique=True)
        return True
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº MongoDB: {e}")

        class MockCursor:
            def sort(self, *a, **kw): return self
            def limit(self, *a, **kw): return self
            def __iter__(self): return iter([])

        class MockCollection:
            def find_one(self, *a, **kw): return None
            def find(self, *a, **kw): return MockCursor()
            def update_one(self, *a, **kw): return None
            def insert_one(self, *a, **kw): return None
            def count_documents(self, *a, **kw): return 0
            def create_index(self, *a, **kw): return None
            def delete_one(self, *a, **kw): return None

        class MockDB:
            def __getitem__(self, name): return MockCollection()
            def command(self, *a, **kw): return None

        db = MockDB()
        return False


def close_db():
    global mongo_client
    if mongo_client:
        mongo_client.close()
        print("ğŸ”Œ MongoDB Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¾")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EMBED_AUTHOR = "ğŸŒ¸ Sunshine Paradise ğŸŒ¸"

# â”€â”€ Ğ¡Ğ•Ğ Ğ’Ğ•Ğ ĞĞ«Ğ™ ĞĞ™Ğ”Ğ˜ Ğ˜ Ğ‘ĞĞ¤Ğ¤Ğ« â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HOME_SERVER_ID = 1168585868882215004  # ID Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€Ğ° Sunshine Paradise

MEMBER_BADGES = {
    # Ğ•ÑĞ»Ğ¸ Ğ¢ĞĞ›Ğ¬ĞšĞ Ñ‚ĞµĞ³ Ğ¸Ğ»Ğ¸ ÑÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€ Ğ² Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ (Ğ½Ğ¾ Ğ½Ğµ Ğ¾Ğ±Ğ° ÑÑ€Ğ°Ğ·Ñƒ)
    "basic": {
        "role_id": 1475882293733363826,
        "multiplier": 1.10,  
        "description": "Ğ¢ĞµĞ³ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸",
        "emoji": "ğŸ·ï¸",
    },
    # Ğ•ÑĞ»Ğ¸ Ñ‚ĞµĞ³  + ÑÑÑ‹Ğ»ĞºĞ° Ğ² Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ 
    "verified": {
        "role_id": 1475884914359406702,
        "multiplier": 1.25,  
        "description": "ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ÑĞµÑ€Ğ²ĞµÑ€Ğ°",
        "emoji": "âœ…",
    },
    # ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞµÑ‰Ñ‘ Ğ±Ğ°Ñ„Ñ„Ñ‹:
    # "premium": {
    #     "role_id": 1234567890,
    #     "multiplier": 1.50,
    #     "description": "ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº",
    #     "emoji": "â­",
    # }
}

XP_PER_MSG = 10
COINS_PER_MSG = 2
XP_COOLDOWN_SEC = 10
DAILY_COINS = 200
DAILY_COOLDOWN_H = 20
WORK_COOLDOWN_MIN = 45
DEFAULT_MSG_REQUIRED = 300

# â”€â”€ Rate limit Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# (uses, per_seconds)  â€” Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ñ‹ Ñ Ğ·Ğ°Ğ¿Ğ°ÑĞ¾Ğ¼ Ğ´Ğ»Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ²
COOLDOWNS = {
    "info_light":  (1, 8),
    "eco_medium":  (1, 15),
    "guild_heavy": (1, 25),
    "super_heavy": (1, 40),
    "rank_ops":    (1, 20),
    "wars":        (1, 90),
}

# Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ñ‚ĞµĞ»ÑŒ Discord-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
# ĞĞµ Ñ‡Ğ°Ñ‰Ğµ 1 Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ² 0.5 Ñ Ğ½Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ğ¾Ğ±ÑŠĞµĞºÑ‚ ĞºĞ°Ğ½Ğ°Ğ»Ğ°/ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
DISCORD_API_DELAY = 0.55  # ÑĞµĞºÑƒĞ½Ğ´ Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ‚ÑĞ¶Ñ‘Ğ»Ñ‹Ğ¼Ğ¸ Discord Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°Ğ¼Ğ¸

LEVELS = {
    1: 0, 2: 300, 3: 700, 4: 1300, 5: 2100,
    6: 3100, 7: 4300, 8: 5700, 9: 7300, 10: 9100,
    11: 11200, 12: 13600, 13: 16300, 14: 19300, 15: 22700,
    16: 26500, 17: 30700, 18: 35300, 19: 40300, 20: 45700,
}
MAX_LEVEL = 20
BASE_MEMBERS = 10

GUILD_RANKS = {
    "owner":     {"name": "ĞÑĞ½Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ",  "icon": "ğŸ‘‘", "color": 0xFFD700, "xp_bonus": 1.5, "coin_bonus": 1.5,
                  "can_invite": True,  "can_kick": True,  "can_promote": True,  "can_edit_settings": True,
                  "can_manage_vault": True,  "can_delete_guild": True,  "priority": 5},
    "viceowner": {"name": "Ğ’Ğ¸Ñ†Ğµ-Ğ»Ğ¸Ğ´ĞµÑ€", "icon": "ğŸ’", "color": 0xDCC0DE, "xp_bonus": 1.3, "coin_bonus": 1.3,
                  "can_invite": True,  "can_kick": True,  "can_promote": True,  "can_edit_settings": False,
                  "can_manage_vault": True,  "can_delete_guild": False, "priority": 4},
    "officer":   {"name": "ĞÑ„Ğ¸Ñ†ĞµÑ€",     "icon": "ğŸ›¡ï¸", "color": 0xC0FFEE, "xp_bonus": 1.15, "coin_bonus": 1.15,
                  "can_invite": True,  "can_kick": True,  "can_promote": False, "can_edit_settings": False,
                  "can_manage_vault": True,  "can_delete_guild": False, "priority": 3},
    "moderator": {"name": "Ğ›ĞµĞ¹Ñ‚ĞµĞ½Ğ°Ğ½Ñ‚", "icon": "ğŸ”¨", "color": 0x9370DB, "xp_bonus": 1.1, "coin_bonus": 1.1,
                  "can_invite": True,  "can_kick": False, "can_promote": False, "can_edit_settings": False,
                  "can_manage_vault": False, "can_delete_guild": False, "priority": 2},
    "member":    {"name": "Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº",   "icon": "ğŸ‘¤", "color": 0x808080, "xp_bonus": 1.0, "coin_bonus": 1.0,
                  "can_invite": False, "can_kick": False, "can_promote": False, "can_edit_settings": False,
                  "can_manage_vault": False, "can_delete_guild": False, "priority": 1},
    "recruit":   {"name": "ĞĞ¾Ğ²Ğ¾Ğ±Ñ€Ğ°Ğ½ĞµÑ†", "icon": "ğŸŒ±", "color": 0x90EE90, "xp_bonus": 0.8, "coin_bonus": 0.8,
                  "can_invite": False, "can_kick": False, "can_promote": False, "can_edit_settings": False,
                  "can_manage_vault": False, "can_delete_guild": False, "priority": 0},
}

GUILD_UPGRADES = {
    "slot_1":   {"price": 2_000,  "members": 5,  "emoji": "ğŸ‘¥", "name": "Ğ¡Ğ»Ğ¾Ñ‚ I"},
    "slot_2":   {"price": 6_000,  "members": 10, "emoji": "ğŸ‘¥", "name": "Ğ¡Ğ»Ğ¾Ñ‚ II"},
    "slot_3":   {"price": 15_000, "members": 20, "emoji": "ğŸ‘¥", "name": "Ğ¡Ğ»Ğ¾Ñ‚ III"},
    "vault_1":  {"price": 3_000,  "members": 0,  "emoji": "ğŸ’°", "name": "ĞšĞ°Ğ·Ğ½Ğ° I"},
    "vault_2":  {"price": 9_000,  "members": 0,  "emoji": "ğŸ’°", "name": "ĞšĞ°Ğ·Ğ½Ğ° II"},
    "prestige": {"price": 25_000, "members": 0,  "emoji": "â­", "name": "ĞŸÑ€ĞµÑÑ‚Ğ¸Ğ¶"},
}

COLORS = {
    "blue":   {"label": "ğŸ”µ Ğ¡Ğ¸Ğ½Ğ¸Ğ¹",      "hex": 0x3498DB, "cat": "ğŸ”µ", "ch": ["ğŸ”¹","ğŸ”·","ğŸ’","ğŸ«","ğŸŒ€","ğŸ§¿"]},
    "red":    {"label": "ğŸ”´ ĞšÑ€Ğ°ÑĞ½Ñ‹Ğ¹",    "hex": 0xE74C3C, "cat": "ğŸ”´", "ch": ["â¤ï¸","ğŸŒ¹","ğŸ","ğŸ”¸","ğŸ’¢","ğŸ¯"]},
    "green":  {"label": "ğŸŸ¢ Ğ—ĞµĞ»Ñ‘Ğ½Ñ‹Ğ¹",   "hex": 0x2ECC71, "cat": "ğŸŸ¢", "ch": ["ğŸ€","ğŸŒ¿","ğŸŒ±","ğŸŒ²","ğŸ¥","ğŸŒ¾"]},
    "gold":   {"label": "ğŸŸ¡ Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾Ğ¹",   "hex": 0xF1C40F, "cat": "ğŸŸ¡", "ch": ["â­","âœ¨","ğŸŒŸ","ğŸ’›","ğŸ…","ğŸ–ï¸"]},
    "purple": {"label": "ğŸŸ£ Ğ¤Ğ¸Ğ¾Ğ»ĞµÑ‚Ğ¾Ğ²Ñ‹Ğ¹","hex": 0x9B59B6, "cat": "ğŸŸ£", "ch": ["ğŸ’œ","ğŸ”®","ğŸŒŒ","ğŸ¦„","ğŸª„","ğŸ«‚"]},
    "pink":   {"label": "ğŸ©· Ğ Ğ¾Ğ·Ğ¾Ğ²Ñ‹Ğ¹",   "hex": 0xFF69B4, "cat": "ğŸ©·", "ch": ["ğŸŒ¸","ğŸŒ·","ğŸŒº","ğŸ€","ğŸ¬","ğŸ’…"]},
    "white":  {"label": "âšª Ğ‘ĞµĞ»Ñ‹Ğ¹",      "hex": 0xDDDDDD, "cat": "âšª", "ch": ["ğŸ¤","ğŸ•Šï¸","â„ï¸","ğŸŒ™","ğŸ«§","ğŸŒ«ï¸"]},
    "orange": {"label": "ğŸŸ  ĞÑ€Ğ°Ğ½Ğ¶ĞµĞ²Ñ‹Ğ¹","hex": 0xE67E22, "cat": "ğŸŸ ", "ch": ["ğŸŠ","ğŸ”¶","ğŸ¦Š","ğŸŒ…","ğŸ”¥","ğŸƒ"]},
    "aqua":   {"label": "ğŸ©µ Ğ“Ğ¾Ğ»ÑƒĞ±Ğ¾Ğ¹",   "hex": 0x1ABC9C, "cat": "ğŸ©µ", "ch": ["ğŸ©µ","ğŸŒŠ","ğŸ¬","ğŸŸ","ğŸ’§","ğŸ«§"]},
}
DEFAULT_COLOR = "blue"

CHANNEL_TPL = [
    {"slug": "Ğ°Ğ½Ğ¾Ğ½ÑÑ‹",   "type": "text",  "readonly": True,  "officers_only": False, "topic": "ĞÑ„Ğ¸Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"},
    {"slug": "Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°",  "type": "text",  "readonly": True,  "officers_only": False, "topic": "ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ¸ ÑƒÑÑ‚Ğ°Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"},
    {"slug": "Ñ‡Ğ°Ñ‚",      "type": "text",  "readonly": False, "officers_only": False, "topic": "ĞĞ±Ñ‰ĞµĞ½Ğ¸Ğµ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²"},
    {"slug": "Ğ¾Ñ„Ğ¸Ñ†ĞµÑ€Ñ‹",  "type": "text",  "readonly": False, "officers_only": True,  "topic": "ĞšĞ°Ğ½Ğ°Ğ» Ğ¾Ñ„Ğ¸Ñ†ĞµÑ€Ğ¾Ğ²"},
    {"slug": "Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ°",  "type": "voice", "readonly": False, "officers_only": False, "topic": ""},
]

SEASON_CH_KEY = "event_channel_id"

WINTER_TASKS = [
    {"id": "wt_snow",   "emoji": "â„ï¸", "name": "Ğ¡Ğ½ĞµĞ¶ĞºĞ¸",       "goal": 10, "reward": 300, "desc": "ĞšĞ¸Ğ½ÑŒ ÑĞ½ĞµĞ¶Ğ¾Ğº 10 Ñ€Ğ°Ğ· (!snowball)"},
    {"id": "wt_warm",   "emoji": "ğŸ”¥", "name": "Ğ¡Ğ¾Ğ³Ñ€ĞµĞ¹ Ğ´Ñ€ÑƒĞ³Ğ°", "goal": 5,  "reward": 200, "desc": "Ğ¡Ğ¾Ğ³Ñ€ĞµĞ¹ 5 Ğ´Ñ€ÑƒĞ·ĞµĞ¹ (!warm @ÑĞ·ĞµÑ€)"},
    {"id": "wt_man",    "emoji": "â›„", "name": "Ğ¡Ğ½ĞµĞ³Ğ¾Ğ²Ğ¸Ğº",     "goal": 1,  "reward": 500, "desc": "Ğ¡Ğ»ĞµĞ¿Ğ¸ ÑĞ½ĞµĞ³Ğ¾Ğ²Ğ¸ĞºĞ° (!snowman)"},
    {"id": "wt_patrol", "emoji": "ğŸ›¡ï¸", "name": "ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒ",      "goal": 3,  "reward": 400, "desc": "Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ (!gpatrol)"},
]
SPRING_TASKS = [
    {"id": "sp_flower", "emoji": "ğŸŒ¸", "name": "Ğ¦Ğ²ĞµÑ‚Ñ‹",   "goal": 15, "reward": 350, "desc": "Ğ¡Ğ¾Ğ±ĞµÑ€Ğ¸ Ñ†Ğ²ĞµÑ‚Ñ‹ 15 Ñ€Ğ°Ğ· (!flower)"},
    {"id": "sp_plant",  "emoji": "ğŸŒ±", "name": "ĞŸĞ¾ÑĞ°Ğ´ĞºĞ°", "goal": 5,  "reward": 250, "desc": "ĞŸĞ¾ÑĞ°Ğ´Ğ¸ Ñ†Ğ²ĞµÑ‚Ğ¾Ğº Ğ´Ñ€ÑƒĞ³Ñƒ (!plant @ÑĞ·ĞµÑ€)"},
    {"id": "sp_rain",   "emoji": "ğŸŒ§ï¸", "name": "Ğ”Ğ¾Ğ¶Ğ´ÑŒ",   "goal": 1,  "reward": 600, "desc": "ĞŸÑ€Ğ¸Ğ·Ğ¾Ğ²Ğ¸ Ğ´Ğ¾Ğ¶Ğ´ÑŒ (!spring_rain)"},
    {"id": "sp_bloom",  "emoji": "ğŸŒº", "name": "Ğ¦Ğ²ĞµÑ‚ĞµĞ½Ğ¸Ğµ","goal": 5,  "reward": 500, "desc": "Ğ£Ñ‡Ğ°ÑÑ‚Ğ²ÑƒĞ¹ Ğ² Ğ´ĞµĞ»Ğ°Ñ… Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"},
]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ… Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ‘ĞĞ¤Ğ¤ĞĞ’ Ğ˜ Ğ’Ğ•Ğ Ğ˜Ğ¤Ğ˜ĞšĞĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ĞšÑÑˆ Ğ±Ğ°Ñ„Ñ„Ğ¾Ğ²: {user_id: (badge_level, multiplier, last_check_time)}
_member_badge_cache = {}
_cache_ttl = 3600  # 1 Ñ‡Ğ°Ñ


async def check_member_profile(member: disnake.Member) -> Optional[str]:
    """
    ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ‚ĞµĞ³Ğ° HOME_SERVER Ğ¸Ğ»Ğ¸ ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€.
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ±Ğ°Ñ„Ñ„: 'verified' â†’ 'basic' â†’ None
    
    ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼:
    1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ¸Ğº Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ‚ĞµĞ³Ğ° ÑĞµÑ€Ğ²ĞµÑ€Ğ° [SP] Ğ¸Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾
    2. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ (bio) Ğ½Ğ° Ñ‚ĞµĞ³ + ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° discord.gg
    3. 'verified' ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ¢ĞĞ“ + Ğ¡Ğ¡Ğ«Ğ›ĞšĞ
    4. 'basic' ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¡Ğ¡Ğ«Ğ›ĞšĞ Ğ¸Ğ»Ğ¸ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¢ĞĞ“
    5. None ĞµÑĞ»Ğ¸ Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾
    """
    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ¼Ñ Ğ¸ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
        display_name = member.display_name or ""
        user_bio = getattr(member, 'bio', '') or ""
        
        # HOME_SERVER_ID = 1168585868882215004 â†’ TAG Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ‚ĞµĞ³Ğ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ (Ğ»ÑĞ±Ğ¾Ğ¹ ĞºĞ»Ğ°Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚ĞµĞ³ Ñ‚Ğ¸Ğ¿Ğ° [NAME])
        has_tag = bool(display_name and '[' in display_name and ']' in display_name)
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€ Discord Ğ¸ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞ³Ğ°
        has_server_link = 'discord.gg' in user_bio.lower()
        
        # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ñ„Ñ„Ğ°
        if has_tag and has_server_link:
            return "verified"  # 1.25x Ğ±Ğ°Ñ„Ñ„
        elif has_tag or has_server_link:
            return "basic"     # 1.10x Ğ±Ğ°Ñ„Ñ„
        else:
            return None        # Ğ±ĞµĞ· Ğ±Ğ°Ñ„Ñ„Ğ°
            
    except Exception as e:
        print(f"[check_member_profile] {e}")
        return None


def get_member_badge_multiplier(member_id: int) -> float:
    """
    ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ±Ğ°Ñ„Ñ„Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ¸Ğ· ĞºÑÑˆĞ°.
    ĞŸĞ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ 1.0 (Ğ±ĞµĞ· Ğ±Ğ°Ñ„Ñ„Ğ°).
    ĞšÑÑˆ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ÑÑ Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡ĞµĞ¹.
    """
    if member_id in _member_badge_cache:
        badge_level, multiplier, _ = _member_badge_cache[member_id]
        if badge_level and badge_level in MEMBER_BADGES:
            return MEMBER_BADGES[badge_level].get("multiplier", 1.0)
    return 1.0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš”ï¸ Ğ‘ĞĞ•Ğ’ĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ˜ ĞĞ›Ğ¬Ğ¯ĞĞ¡Ğ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ARMY_UNITS = {
    "recruit": {
        "name": "ğŸ”± ĞĞ¾Ğ²Ğ¾Ğ±Ñ€Ğ°Ğ½ĞµÑ†",
        "cost": 500,
        "power": 1,
        "emoji": "ğŸ”±",
    },
    "soldier": {
        "name": "âš”ï¸ Ğ‘Ğ¾ĞµÑ†",
        "cost": 2000,
        "power": 3,
        "emoji": "âš”ï¸",
    },
    "knight": {
        "name": "ğŸ›¡ï¸ Ğ Ñ‹Ñ†Ğ°Ñ€ÑŒ",
        "cost": 8000,
        "power": 8,
        "emoji": "ğŸ›¡ï¸",
    },
    "champion": {
        "name": "ğŸ‘‘ Ğ§ĞµĞ¼Ğ¿Ğ¸Ğ¾Ğ½",
        "cost": 25000,
        "power": 20,
        "emoji": "ğŸ‘‘",
    },
    "legend": {
        "name": "âœ¨ Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°",
        "cost": 100000,
        "power": 50,
        "emoji": "âœ¨",
    },
}

ATTACK_TYPES = {
    "raid": {
        "name": "Ğ ĞµĞ¹Ğ´",
        "cost": 5000,
        "loot_percent": 0.15,
        "emoji": "ğŸ”¥",
    },
    "siege": {
        "name": "ĞÑĞ°Ğ´Ğ°",
        "cost": 15000,
        "loot_percent": 0.30,
        "emoji": "ğŸšï¸",
    },
    "conquest": {
        "name": "Ğ—Ğ°Ğ²Ğ¾ĞµĞ²Ğ°Ğ½Ğ¸Ğµ",
        "cost": 50000,
        "loot_percent": 0.50,
        "emoji": "ğŸ‘‘",
    },
}

TECHNOLOGIES = {
    "iron_infantry": {
        "name": "ğŸ—ï¸ Ğ–ĞµĞ»ĞµĞ·Ğ½Ğ°Ñ Ğ¿ĞµÑ…Ğ¾Ñ‚Ğ°",
        "description": "Ğ‘Ğ¾ĞµĞ²Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ +20%",
        "cost": 50000,
        "bonus": 0.20,
        "type": "power",
    },
    "shield_mastery": {
        "name": "ğŸ›¡ï¸ ĞœĞ°ÑÑ‚ĞµÑ€ÑÑ‚Ğ²Ğ¾ Ñ‰Ğ¸Ñ‚Ğ°", 
        "description": "Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° +30%",
        "cost": 40000,
        "bonus": 0.30,
        "type": "defense",
    },
    "supply_chain": {
        "name": "ğŸ“¦ Ğ¦ĞµĞ¿ÑŒ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¾Ğº",
        "description": "Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ Ğ½Ğ° Ğ°Ñ€Ğ¼Ğ¸Ğ¸ -20%",
        "cost": 30000,
        "bonus": 0.20,
        "type": "economy",
    },
    "espionage": {
        "name": "ğŸ•µï¸ Ğ Ğ°Ğ·Ğ²ĞµĞ´ĞºĞ°",
        "description": "Ğ’Ğ¸Ğ´Ğ¸ÑˆÑŒ Ğ²Ğ¾Ğ¹ÑĞº Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸ĞºĞ°",
        "cost": 60000,
        "bonus": 0,
        "type": "info",
    },
    "fortifications": {
        "name": "ğŸ° Ğ£ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ñ",
        "description": "Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° ĞºĞ°Ğ·Ğ½Ñ‹ +40%",
        "cost": 80000,
        "bonus": 0.40,
        "type": "vault_defense",
    },
}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¾ Ğ‘ĞĞ—Ğ Ğ”ĞĞĞĞ«Ğ¥
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _udef() -> dict:
    return {
        "xp": 0, "level": 1, "coins": 0, "messages": 0,
        "guild_id": None, "guild_rank": None,
        "last_xp": None, "daily_last": None, "work_last": None,
        "event_progress": {}, "event_claimed": [],
        # === ĞĞĞ’ĞĞ•: Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ° ===
        "farms": [],  # Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ĞºĞ»ÑÑ‡ĞµĞ¹ Ñ„ĞµÑ€Ğ¼ Ñ‚Ğ¸Ğ¿Ğ° ["flower_garden", "honey_hives"]
        "last_farm_income": None,  # Timestamp Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ ÑĞ±Ğ¾Ñ€Ğ° Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ°
        "farm_income_collected": 0,  # Ğ˜Ğ½Ñ‚Ğ½Ğ°ĞºĞ¾Ğ¿Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´ Ğ·Ğ° Ğ´ĞµĞ½ÑŒ
    }


def get_user(uid: str, sid: str) -> dict:
    try:
        doc = db["users"].find_one({"user_id": uid, "server_id": sid})
        if not doc:
            new_user = {"user_id": uid, "server_id": sid, **_udef()}
            db["users"].insert_one(new_user)
            return new_user
        return dict(doc)
    except Exception as e:
        print(f"âŒ get_user: {e}")
        return {"user_id": uid, "server_id": sid, **_udef()}


def save_user(uid: str, sid: str, patch: dict):
    try:
        db["users"].update_one(
            {"user_id": uid, "server_id": sid},
            {"$set": patch},
            upsert=True
        )
    except Exception as e:
        print(f"âŒ save_user: {e}")


def get_settings(sid: str) -> dict:
    try:
        doc = db["settings"].find_one({"server_id": sid})
        return dict(doc) if doc else {"server_id": sid}
    except Exception as e:
        print(f"âŒ get_settings: {e}")
        return {}


def save_settings(sid: str, patch: dict):
    try:
        db["settings"].update_one({"server_id": sid}, {"$set": patch}, upsert=True)
    except Exception as e:
        print(f"âŒ save_settings: {e}")


def get_msg_required(sid: str) -> int:
    return get_settings(sid).get("msg_required", DEFAULT_MSG_REQUIRED)


def get_guild(gid: str) -> Optional[dict]:
    try:
        doc = db["guilds"].find_one({"id": gid})
        return dict(doc) if doc else None
    except Exception as e:
        print(f"âŒ get_guild: {e}")
        return None


def save_guild(gid: str, patch: dict):
    try:
        db["guilds"].update_one({"id": gid}, {"$set": patch}, upsert=True)
    except Exception as e:
        print(f"âŒ save_guild: {e}")


def guild_by_tag(sid: str, tag: str) -> Optional[dict]:
    try:
        doc = db["guilds"].find_one({"server_id": sid, "tag": tag.upper()})
        return dict(doc) if doc else None
    except Exception as e:
        print(f"âŒ guild_by_tag: {e}")
        return None


def guild_members(gid: str, sid: str) -> List[dict]:
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº dict Ñ ĞºĞ»ÑÑ‡Ğ¾Ğ¼ 'user_id' (Ğ²ÑĞµĞ³Ğ´Ğ°)."""
    try:
        return [dict(m) for m in db["users"].find({"server_id": sid, "guild_id": gid})]
    except Exception as e:
        print(f"âŒ guild_members: {e}")
        return []


def member_count(gid: str, sid: str) -> int:
    try:
        return db["users"].count_documents({"server_id": sid, "guild_id": gid})
    except Exception as e:
        print(f"âŒ member_count: {e}")
        return 0


def calc_guild_power(gd: dict, sid: str) -> int:
    """Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ¼Ğ¾Ñ‰ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼"""
    members = member_count(gd["id"], sid)
    
    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ Ğ¾Ñ‚ ĞºĞ°Ğ·Ğ½Ñ‹
    power = gd.get("bank", 0) // 100
    
    # ĞœĞ¾Ñ‰ÑŒ Ğ¾Ñ‚ Ñ‡Ğ»ĞµĞ½Ğ¾Ğ²
    power += members * 50
    
    # ĞœĞ¾Ñ‰ÑŒ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ±ĞµĞ´
    power += gd.get("wins", 0) * 200
    
    # ĞœĞ¾Ñ‰ÑŒ Ğ¾Ñ‚ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ²
    upgrades = gd.get("upgrades", [])
    power += len(upgrades) * 300
    
    # ĞœĞ¾Ñ‰ÑŒ Ğ¾Ñ‚ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ, Ñ‚Ğ¾ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ²Ğ°Ğ»Ğ°ÑÑŒ)
    if gd.get("description"):
        power += 500
    
    # ĞœĞ¾Ñ‰ÑŒ Ğ¾Ñ‚ Ñ†Ğ²ĞµÑ‚Ğ° ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ° (ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚)
    if gd.get("color") and gd.get("color") != DEFAULT_COLOR:
        power += 200
    
    return max(1, power)


def calc_guild_level(gd: dict, sid: str) -> tuple:
    """Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¸ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸: (level, xp, xp_needed)"""
    xp = gd.get("level_xp", 0)
    level = gd.get("level", 1)
    
    # XP Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ: 1000 + (level * 500)
    xp_needed = 1000 + (level * 500)
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ
    while xp >= xp_needed:
        xp -= xp_needed
        level += 1
        xp_needed = 1000 + (level * 500)
    
    return level, xp, xp_needed


def add_guild_xp(gid: str, amount: int):
    """Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
    try:
        gd = db["guilds"].find_one({"id": gid})
        if gd:
            xp = gd.get("level_xp", 0) + amount
            level = gd.get("level", 1)
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ñ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ
            xp_needed = 1000 + (level * 500)
            while xp >= xp_needed:
                xp -= xp_needed
                level += 1
                xp_needed = 1000 + (level * 500)
            
            db["guilds"].update_one({"id": gid}, {
                "$set": {"level_xp": xp, "level": level}
            })
    except Exception as e:
        print(f"[add_guild_xp] Error: {e}")


def member_limit(upgrades: list) -> int:
    base = BASE_MEMBERS
    for k in upgrades:
        upg = GUILD_UPGRADES.get(k)
        if upg:
            base += upg["members"]
    return base


def get_alliance(sid: str, name: str) -> Optional[dict]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ Ğ¿Ğ¾ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ."""
    try:
        doc = db["alliances"].find_one({"server_id": sid, "name": name.lower()})
        return dict(doc) if doc else None
    except Exception as e:
        print(f"âŒ get_alliance: {e}")
        return None


def get_alliance_by_id(alliance_id: str) -> Optional[dict]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ Ğ¿Ğ¾ ID."""
    try:
        doc = db["alliances"].find_one({"id": alliance_id})
        return dict(doc) if doc else None
    except Exception as e:
        print(f"âŒ get_alliance_by_id: {e}")
        return None


def save_alliance(alliance_id: str, patch: dict):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ°Ğ»ÑŒÑĞ½ÑĞ°."""
    try:
        db["alliances"].update_one({"id": alliance_id}, {"$set": patch}, upsert=True)
    except Exception as e:
        print(f"âŒ save_alliance: {e}")


def get_guild_alliances(gid: str) -> List[dict]:
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½ÑÑ‹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸."""
    try:
        return [dict(a) for a in db["alliances"].find({"members": gid})]
    except Exception as e:
        print(f"âŒ get_guild_alliances: {e}")
        return []



def calc_level(xp: int) -> int:
    lvl = 1
    for lv, req in LEVELS.items():
        if xp >= req:
            lvl = lv
    return min(lvl, MAX_LEVEL)


def xp_needed(xp: int, lvl: int) -> int:
    nxt = lvl + 1
    return 0 if nxt > MAX_LEVEL else LEVELS[nxt] - xp


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ Ğ£Ğ¢Ğ˜Ğ›Ğ˜Ğ¢Ğ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def chex(color: str) -> int:
    return COLORS.get(color, COLORS[DEFAULT_COLOR])["hex"]

def ch_emojis(color: str) -> List[str]:
    return COLORS.get(color, COLORS[DEFAULT_COLOR])["ch"]

def cat_em(color: str) -> str:
    return COLORS.get(color, COLORS[DEFAULT_COLOR])["cat"]

def rank_icon(rank: str) -> str:
    return GUILD_RANKS.get(rank, GUILD_RANKS["member"]).get("icon", "ğŸ‘¤")

def rank_name(rank: str) -> str:
    return GUILD_RANKS.get(rank, GUILD_RANKS["member"]).get("name", "Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº")

def rank_color(rank: str) -> int:
    return GUILD_RANKS.get(rank, GUILD_RANKS["member"]).get("color", 0x808080)

def has_privilege(rank: str, privilege: str) -> bool:
    return GUILD_RANKS.get(rank, GUILD_RANKS["member"]).get(f"can_{privilege}", False)

def pbar(cur: int, goal: int, n: int = 10) -> str:
    f = int(min(cur, goal) / max(goal, 1) * n)
    return "â–ˆ" * f + "â–‘" * (n - f)

def ce(title: str, desc: str, srv: disnake.Guild, color: int = 0xFF69B4) -> disnake.Embed:
    e = disnake.Embed(title=title, description=desc, color=color)
    e.set_author(name=EMBED_AUTHOR, icon_url=srv.icon.url if srv.icon else None)
    e.timestamp = datetime.utcnow()
    return e

def ge(title: str, desc: str, gdata: dict, srv: disnake.Guild) -> disnake.Embed:
    return ce(title, desc, srv, chex(gdata.get("color", DEFAULT_COLOR)))

def uid_from_member_doc(doc: dict) -> Optional[str]:
    """Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¸Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµÑ‚ user_id Ğ¸Ğ· Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."""
    if not doc:
        return None
    return doc.get("user_id") or doc.get("uid") or doc.get("_id")


# â”€â”€ ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ V1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def invite_row(gid: str, inviter_id: int, invited_id: int) -> disnake.ui.ActionRow:
    return disnake.ui.ActionRow(
        disnake.ui.Button(label="âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ",  style=disnake.ButtonStyle.success,
                          custom_id=f"invite:accept:{gid}:{inviter_id}:{invited_id}"),
        disnake.ui.Button(label="âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", style=disnake.ButtonStyle.danger,
                          custom_id=f"invite:decline:{gid}:{inviter_id}:{invited_id}"),
    )

def page_row(owner_id: int, page: int, total: int, key: str) -> disnake.ui.ActionRow:
    return disnake.ui.ActionRow(
        disnake.ui.Button(label="â—€ï¸", style=disnake.ButtonStyle.secondary,
                          custom_id=f"page:prev:{owner_id}:{page}:{total}:{key}",
                          disabled=page == 0),
        disnake.ui.Button(label="â–¶ï¸", style=disnake.ButtonStyle.secondary,
                          custom_id=f"page:next:{owner_id}:{page}:{total}:{key}",
                          disabled=page >= total - 1),
    )

def season_claim_row(uid: int, season: str) -> disnake.ui.ActionRow:
    return disnake.ui.ActionRow(
        disnake.ui.Button(label="ğŸ“¬ Ğ—Ğ°Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹", style=disnake.ButtonStyle.success,
                          custom_id=f"season:claim:{uid}:{season}"),
    )

def disabled_row(*labels_and_styles) -> disnake.ui.ActionRow:
    btns = []
    for idx, (label, style) in enumerate(labels_and_styles):
        btns.append(disnake.ui.Button(label=label, style=style,
                                       custom_id=f"disabled_noop_{idx}_{random.randint(0, 999999)}",
                                       disabled=True))
    return disnake.ui.ActionRow(*btns)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ—ï¸ ĞšĞĞĞĞ›Ğ« Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def _safe_delete(obj, delay: float = DISCORD_API_DELAY):
    """Ğ£Ğ´Ğ°Ğ»ÑĞµÑ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚ Discord Ñ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¾Ğ¹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº."""
    try:
        await asyncio.sleep(delay)
        await obj.delete()
    except disnake.NotFound:
        pass
    except disnake.HTTPException as e:
        if e.status == 429:
            retry = e.response.headers.get("Retry-After", 5)
            await asyncio.sleep(float(retry) + 1)
            try:
                await obj.delete()
            except Exception:
                pass
    except Exception as ex:
        print(f"[safe_delete] {ex}")


async def create_guild_role(srv: disnake.Guild, tag: str, color: int) -> Optional[disnake.Role]:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸."""
    try:
        role_name = f"[{tag}] Ğ§Ğ»ĞµĞ½Ñ‹"
        role = await srv.create_role(
            name=role_name,
            color=disnake.Color(color),
            reason="Ğ Ğ¾Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ¾Ğ¼"
        )
        return role
    except Exception as e:
        print(f"[create_guild_role] {e}")
        return None


async def build_channels(
    srv: disnake.Guild, name: str, tag: str, color: str, owner: disnake.Member,
) -> Tuple[Optional[disnake.CategoryChannel], list]:
    emojis = ch_emojis(color)
    n = len(CHANNEL_TPL)
    cat_ow = {
        srv.default_role: disnake.PermissionOverwrite(read_messages=False, connect=False),
        srv.me: disnake.PermissionOverwrite(read_messages=True, manage_channels=True,
                                             manage_permissions=True, connect=True),
        owner: disnake.PermissionOverwrite(read_messages=True, send_messages=True,
                                            connect=True, manage_messages=True),
    }
    try:
        cat = await srv.create_category(f"â€”â€”ãƒ»{name.upper()}", overwrites=cat_ow)
    except disnake.Forbidden:
        return None, []
    except disnake.HTTPException as e:
        print(f"[build_channels] category: {e}")
        return None, []

    created = []
    for i, tpl in enumerate(CHANNEL_TPL):
        await asyncio.sleep(DISCORD_API_DELAY)
        border = "â”" if i == 0 else ("â”–" if i == n - 1 else "â”ƒ")
        em = emojis[i % len(emojis)]
        cname = f"{border}ã€{em}ã€‘{tpl['slug']}"
        ow = {
            srv.default_role: disnake.PermissionOverwrite(read_messages=False, connect=False),
            srv.me: disnake.PermissionOverwrite(read_messages=True, send_messages=True, connect=True),
            owner: disnake.PermissionOverwrite(read_messages=True, send_messages=True, connect=True),
        }
        try:
            if tpl["type"] == "voice":
                obj = await srv.create_voice_channel(cname, category=cat, overwrites=ow)
            else:
                obj = await srv.create_text_channel(
                    cname, category=cat, topic=tpl.get("topic", ""), overwrites=ow)
                if tpl["readonly"]:
                    await asyncio.sleep(DISCORD_API_DELAY)
                    await obj.set_permissions(owner, read_messages=True,
                                              send_messages=True, manage_messages=True)
            created.append({"id": obj.id, "slug": tpl["slug"], "type": tpl["type"]})
        except disnake.HTTPException as e:
            if e.status == 429:
                retry = float(e.response.headers.get("Retry-After", 5)) + 1
                print(f"[build_channels] rate limited, waiting {retry}s")
                await asyncio.sleep(retry)
            else:
                print(f"[build_channels] {tpl['slug']}: {e}")
        except Exception as ex:
            print(f"[build_channels] {tpl['slug']}: {ex}")

    return cat, created


async def refresh_access(srv: disnake.Guild, gdata: dict, member: disnake.Member, remove: bool = False):
    cat_id = gdata.get("category_id")
    if not cat_id:
        return
    cat = srv.get_channel(int(cat_id))
    if not cat:
        return
    u = get_user(str(member.id), str(srv.id))
    rank = u.get("guild_rank", "member")
    privileged_ranks = [r for r, d in GUILD_RANKS.items() if d.get("can_manage_vault")]

    for ch in cat.channels:
        slug = next((c["slug"] for c in gdata.get("channels", []) if c.get("id") == ch.id), "")
        tpl = next((t for t in CHANNEL_TPL if t["slug"] == slug), None)
        try:
            await asyncio.sleep(DISCORD_API_DELAY)
            if remove:
                await ch.set_permissions(member, overwrite=None)
            elif tpl and tpl.get("officers_only") and rank not in privileged_ranks:
                await ch.set_permissions(member, read_messages=False)
            else:
                if isinstance(ch, disnake.VoiceChannel):
                    await ch.set_permissions(member, read_messages=True, connect=True)
                else:
                    is_readonly = tpl.get("readonly", False) if tpl else False
                    can_write = (not is_readonly) or has_privilege(rank, "manage_vault")
                    can_manage = has_privilege(rank, "manage_vault")
                    await ch.set_permissions(member, read_messages=True,
                                              send_messages=can_write,
                                              manage_messages=can_manage)
        except disnake.HTTPException as e:
            if e.status == 429:
                await asyncio.sleep(float(e.response.headers.get("Retry-After", 5)) + 1)
        except Exception:
            pass


async def rebuild(srv: disnake.Guild, gdata: dict, owner: disnake.Member):
    """ĞŸĞµÑ€ĞµÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¾Ğ¹ Ğ¾Ñ‚ rate-limit."""
    cat_id = gdata.get("category_id")
    if cat_id:
        old = srv.get_channel(int(cat_id))
        if old:
            for ch in list(old.channels):
                await _safe_delete(ch)
            await _safe_delete(old)

    cat, chs = await build_channels(srv, gdata["name"], gdata["tag"], gdata["color"], owner)
    gdata["category_id"] = cat.id if cat else None
    gdata["channels"] = chs
    gdata["server_id"] = str(srv.id)
    save_guild(gdata["id"], gdata)

    sid = str(srv.id)
    for m in guild_members(gdata["id"], sid):
        uid = uid_from_member_doc(m)
        if uid:
            mo = srv.get_member(int(uid))
            if mo:
                await refresh_access(srv, gdata, mo)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¬ Ğ›Ğ¡ Ğ”Ğ˜ĞĞ›ĞĞ“ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def creation_dialog(ctx: commands.Context, bot: commands.Bot) -> Optional[dict]:
    author = ctx.author

    def dmcheck(m):
        return m.author.id == author.id and isinstance(m.channel, disnake.DMChannel)

    try:
        dm = await author.create_dm()
        await dm.send(embed=disnake.Embed(
            title="ğŸŒ¸ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ â€” Sunshine Paradise",
            description=(
                "> ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¡Ğ»ĞµĞ´ÑƒĞ¹ ÑˆĞ°Ğ³Ğ°Ğ¼, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ.\n> _ _\n"
                "> ĞĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑˆĞ°Ğ³ **60 ÑĞµĞºÑƒĞ½Ğ´**. ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ `Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ°` Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€ĞµÑ€Ğ²Ğ°Ñ‚ÑŒ.\n> _ _\n"
                "> **Ğ¨Ğ°Ğ³ 1 / 4 Â·** Ğ’Ğ²ĞµĞ´Ğ¸ **Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ** Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ (2â€“30 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²):"
            ), color=0xFF69B4).set_author(name=EMBED_AUTHOR))
    except disnake.Forbidden:
        await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°",
                                "> **âŒ ĞĞµ Ğ¼Ğ¾Ğ³Ñƒ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ² Ğ›Ğ¡!** Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ¸ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ.",
                                ctx.guild, 0xFF0000))
        return None

    await ctx.send(embed=ce("ğŸŒ¸ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸",
                             f"> {author.mention}, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒ **Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ** ğŸ“¬", ctx.guild))

    async def step(prompt_embed=None) -> Optional[str]:
        if prompt_embed:
            await dm.send(embed=prompt_embed)
        try:
            m = await bot.wait_for("message", check=dmcheck, timeout=60)
        except asyncio.TimeoutError:
            await dm.send("â° Ğ’Ñ€ĞµĞ¼Ñ Ğ²Ñ‹ÑˆĞ»Ğ¾.")
            return None
        if m.content.lower() == "Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ°":
            await dm.send("âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.")
            return None
        return m.content.strip()

    # Ğ¨Ğ°Ğ³ 1 â€” ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ
    name_raw = await step()
    if not name_raw:
        return None
    name = name_raw
    if not 2 <= len(name) <= 30:
        await dm.send("âŒ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: 2â€“30 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ². ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.")
        return None

    # Ğ¨Ğ°Ğ³ 2 â€” Ğ¢ĞµĞ³
    tag_raw = await step(disnake.Embed(
        title="ğŸŒ¸ Ğ¨Ğ°Ğ³ 2 / 4 Â· Ğ¢ĞµĞ³",
        description=(f"> âœ… ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: **{name}**\n> _ _\n"
                     "> Ğ’Ğ²ĞµĞ´Ğ¸ **Ñ‚ĞµĞ³** (2â€“5 Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ñ… Ğ±ÑƒĞºĞ²/Ñ†Ğ¸Ñ„Ñ€). ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: `SP`, `GP1`"),
        color=0xFF69B4).set_author(name=EMBED_AUTHOR))
    if not tag_raw:
        return None
    tag = tag_raw.upper()
    if not (2 <= len(tag) <= 5 and tag.isascii() and tag.isalnum()):
        await dm.send("âŒ Ğ¢ĞµĞ³: 2â€“5 Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ñ… Ğ±ÑƒĞºĞ²/Ñ†Ğ¸Ñ„Ñ€. ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.")
        return None

    # Ğ¨Ğ°Ğ³ 3 â€” ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ
    desc_raw = await step(disnake.Embed(
        title="ğŸŒ¸ Ğ¨Ğ°Ğ³ 3 / 4 Â· ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
        description=(f"> âœ… ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: **{name}**\n> âœ… Ğ¢ĞµĞ³: **[{tag}]**\n> _ _\n"
                     "> Ğ’Ğ²ĞµĞ´Ğ¸ **Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ** (Ğ´Ğ¾ 100 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²) Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸ `Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ`:"),
        color=0xFF69B4).set_author(name=EMBED_AUTHOR))
    if desc_raw is None:
        return None
    desc = "ĞĞµÑ‚ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ" if desc_raw.lower() == "Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ" else desc_raw[:100]

    # Ğ¨Ğ°Ğ³ 4 â€” Ğ¦Ğ²ĞµÑ‚
    colors_line = " | ".join(f"`{k}` {v['label']}" for k, v in COLORS.items())
    color_raw = await step(disnake.Embed(
        title="ğŸŒ¸ Ğ¨Ğ°Ğ³ 4 / 4 Â· Ğ¦Ğ²ĞµÑ‚",
        description=(f"> âœ… ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: **{name}**\n> âœ… Ğ¢ĞµĞ³: **[{tag}]**\n"
                     f"> âœ… ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: _{desc}_\n> _ _\n> ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ **Ñ†Ğ²ĞµÑ‚**:\n> {colors_line}"),
        color=0xFF69B4).set_author(name=EMBED_AUTHOR))
    color = DEFAULT_COLOR
    if color_raw and color_raw.lower() in COLORS:
        color = color_raw.lower()
    elif color_raw:
        await dm.send(f"âš ï¸ Ğ¦Ğ²ĞµÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ **{DEFAULT_COLOR}**.")

    ci = COLORS[color]
    await dm.send(embed=disnake.Embed(
        title="âœ… Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ±ÑƒĞ´ĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!",
        description=(f"> **ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ:** {name}\n> **Ğ¢ĞµĞ³:** [{tag}]\n"
                     f"> **ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:** _{desc}_\n> **Ğ¦Ğ²ĞµÑ‚:** {ci['label']}\n"
                     "> _ _\n> Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹ÑÑ Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€! ğŸ‰"),
        color=ci["hex"]).set_author(name=EMBED_AUTHOR))
    return {"name": name, "tag": tag, "desc": desc, "color": color}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¦ Ğ¥Ğ ĞĞĞ˜Ğ›Ğ˜Ğ©Ğ• ĞŸĞĞ“Ğ˜ĞĞĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
_page_store: dict = {}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¤– ĞšĞĞ“
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_admin():
    async def predicate(ctx):
        return ctx.author.guild_permissions.administrator or ctx.author.id == 1187841298007330836
    return commands.check(predicate)


class GuildCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self._xpcd: dict = {}
        if not self.season_task.is_running():
            self.season_task.start()
        if not self.verify_member_badges_task.is_running():
            self.verify_member_badges_task.start()

    def cog_unload(self):
        self.season_task.cancel()
        self.verify_member_badges_task.cancel()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“¨ XP + ĞœĞĞĞ•Ğ¢Ğ« Ğ—Ğ Ğ¡ĞĞĞ‘Ğ©Ğ•ĞĞ˜Ğ¯ (ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ on_message)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.Cog.listener()
    async def on_message(self, msg: disnake.Message):
        if msg.author.bot or not msg.guild:
            return
        uid, sid = str(msg.author.id), str(msg.guild.id)
        now = datetime.utcnow()
        key = f"{sid}:{uid}"

        u = get_user(uid, sid)
        patch: dict = {"messages": u.get("messages", 0) + 1}

        last = self._xpcd.get(key)
        can_gain = not last or (now - last).total_seconds() >= XP_COOLDOWN_SEC
        if can_gain:
            self._xpcd[key] = now
            rank = u.get("guild_rank") or "member"
            rd = GUILD_RANKS.get(rank, GUILD_RANKS["member"])
            xp_gain  = int(XP_PER_MSG   * rd.get("xp_bonus", 1.0))
            co_gain  = int(COINS_PER_MSG * rd.get("coin_bonus", 1.0))
            
            # ğŸ… ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ±Ğ°Ñ„Ñ„Ğ°
            badge_multiplier = get_member_badge_multiplier(msg.author.id)
            co_gain = int(co_gain * badge_multiplier)
            
            new_xp   = u.get("xp", 0) + xp_gain
            new_lvl  = calc_level(new_xp)
            old_lvl  = u.get("level", 1)
            patch.update({"xp": new_xp, "level": new_lvl,
                           "coins": u.get("coins", 0) + co_gain,
                           "last_xp": now.isoformat()})
            save_user(uid, sid, patch)
            if new_lvl > old_lvl:
                bonus = new_lvl * 50
                save_user(uid, sid, {"coins": u.get("coins", 0) + co_gain + bonus})
                try:
                    await msg.channel.send(
                        embed=ce("â¬†ï¸ Level Up!",
                                 f"> {msg.author.mention} Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³ **{new_lvl} ÑƒÑ€Ğ¾Ğ²Ğ½Ñ**! ğŸ‰\n"
                                 f"> ğŸ Ğ‘Ğ¾Ğ½ÑƒÑ: **+{bonus} Ğ¼Ğ¾Ğ½ĞµÑ‚**", msg.guild),
                        delete_after=12)
                except Exception:
                    pass
        else:
            save_user(uid, sid, patch)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”˜ ĞšĞĞœĞŸĞĞĞ•ĞĞ¢Ğ« (ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.Cog.listener()
    async def on_message_interaction(self, i: disnake.MessageInteraction):
        cid = i.data.custom_id

        # â”€â”€ Invite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if cid.startswith("invite:"):
            parts = cid.split(":")
            if len(parts) < 5:
                return
            action, gid, inviter_id, invited_id = parts[1], parts[2], int(parts[3]), int(parts[4])
            if i.user.id != invited_id:
                await i.response.send_message("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ²Ğ¾Ñ‘ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ!", ephemeral=True)
                return
            gd = get_guild(gid)
            guild = i.guild or (self.bot.get_guild(int(gd["server_id"])) if gd else None)
            if not guild or not gd:
                await i.response.edit_message(
                    content="âŒ Ğ¡ĞµÑ€Ğ²ĞµÑ€ Ğ¸Ğ»Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹.", embed=None, components=[])
                return
            sid = str(guild.id)
            dis_row = disabled_row(("âœ… ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ", disnake.ButtonStyle.success),
                                    ("âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", disnake.ButtonStyle.danger))

            if action == "decline":
                await i.response.edit_message(
                    embed=ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", f"> âŒ **{i.user.mention}** Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ğ»(Ğ°) Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ.",
                              guild, 0xFF4444), components=[dis_row])
                return

            u = get_user(str(invited_id), sid)
            if u.get("guild_id"):
                await i.response.edit_message(
                    embed=ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", guild, 0xFF0000),
                    components=[dis_row])
                return
            cnt = member_count(gid, sid)
            limit = member_limit(gd.get("upgrades", []))
            if cnt >= limit:
                await i.response.edit_message(
                    embed=ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", f"> **âŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°!** ({cnt}/{limit})",
                              guild, 0xFF0000), components=[dis_row])
                return
            save_user(str(invited_id), sid, {"guild_id": gid, "guild_rank": "member"})
            invited = guild.get_member(invited_id)
            if invited:
                await refresh_access(guild, gd, invited)
                
                # ğŸ… Ğ”Ğ°Ñ‘Ğ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
                guild_role_id = gd.get("guild_role_id")
                if guild_role_id:
                    guild_role = guild.get_role(guild_role_id)
                    if guild_role:
                        try:
                            await invited.add_roles(guild_role, reason=f"Ğ’ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ {gd['tag']}")
                        except Exception as e:
                            print(f"[invite:accept] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾ĞµĞ½Ğ¸Ğ¸ Ñ€Ğ¾Ğ»Ğ¸: {e}")
                
                try:
                    old = invited.display_name
                    if old.startswith("[") and "]" in old:
                        old = old.split("]", 1)[1].strip()
                    await invited.edit(nick=f"[{gd['tag']}] {old}"[:32])
                except Exception:
                    pass
            await i.response.edit_message(
                embed=ge("ğŸŒ¸ Ğ’ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ", f"> âœ… **{i.user.mention}** Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ğ»(Ğ°) Ğ² **[{gd['tag']}] {gd['name']}**! ğŸ‰",
                          gd, guild), components=[dis_row])

        # â”€â”€ Pagination â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif cid.startswith("page:"):
            parts = cid.split(":")
            if len(parts) < 6:
                return
            action, owner_id, page, total, key = parts[1], int(parts[2]), int(parts[3]), int(parts[4]), parts[5]
            if i.user.id != owner_id:
                await i.response.send_message("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ²Ğ¾Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº!", ephemeral=True)
                return
            page = page - 1 if action == "prev" else page + 1
            page = max(0, min(page, total - 1))
            pages = _page_store.get(key, [])
            if not pages:
                await i.response.send_message("âŒ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ»Ğ¸, Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ.", ephemeral=True)
                return
            title_fmt = _page_store.get(key + ":title", "ğŸ“‹ ({}/{})")
            await i.response.edit_message(
                embed=ce(title_fmt.format(page + 1, total), pages[page], i.guild),
                components=[page_row(owner_id, page, total, key)])

        # â”€â”€ Season claim â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif cid.startswith("season:claim:"):
            parts = cid.split(":")
            uid, season = str(parts[2]), parts[3]
            if str(i.user.id) != uid:
                await i.response.send_message("âŒ Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ²Ğ¾Ğ¸ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ!", ephemeral=True)
                return
            sid = str(i.guild.id)
            u = get_user(uid, sid)
            pr = u.get("event_progress", {})
            cl = u.get("event_claimed", [])
            task_list = WINTER_TASKS if season == "winter" else SPRING_TASKS
            earned, total_coins = [], 0
            for t in task_list:
                if t["id"] in cl:
                    continue
                if pr.get(t["id"], 0) >= t["goal"]:
                    cl.append(t["id"])
                    total_coins += t["reward"]
                    earned.append(f"> {t['emoji']} **{t['name']}** â†’ +{t['reward']:,} Ğ¼Ğ¾Ğ½ĞµÑ‚")
            if not earned:
                await i.response.send_message(
                    embed=ce("Ğ˜Ğ²ĞµĞ½Ñ‚", "> **âŒ ĞĞµÑ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğ¹!**", i.guild, 0xFF4444),
                    ephemeral=True)
                return
            save_user(uid, sid, {"event_claimed": cl, "coins": u.get("coins", 0) + total_coins})
            await i.response.send_message(
                embed=ce("ğŸŒ¸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ñ‹!",
                          "> _ _\n" + "\n".join(earned) + f"\n> _ _\n> **Ğ˜Ñ‚Ğ¾Ğ³Ğ¾:** +{total_coins:,} Ğ¼Ğ¾Ğ½ĞµÑ‚",
                          i.guild), ephemeral=True)

        elif cid.startswith("disabled_noop"):
            await i.response.defer()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ’° Ğ­ĞšĞĞĞĞœĞ˜ĞšĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="profile", aliases=["prof"])
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def profile(self, ctx: commands.Context, member: disnake.Member = None):
        target = member or ctx.author
        uid, sid = str(target.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        lvl = u.get("level", 1)
        xp  = u.get("xp", 0)
        nxt = xp_needed(xp, lvl)
        cur  = xp - LEVELS.get(lvl, 0)
        goal = (LEVELS.get(lvl + 1, LEVELS[MAX_LEVEL]) - LEVELS.get(lvl, 0)) if lvl < MAX_LEVEL else 1
        bar  = pbar(cur, goal)
        g_line = "â€”"
        if u.get("guild_id"):
            gd = get_guild(u["guild_id"])
            if gd:
                g_line = f"[{gd['tag']}] {gd['name']}"
        msg_req  = get_msg_required(sid)
        msg_line = ""
        if not u.get("guild_id") and u.get("messages", 0) < msg_req:
            need = msg_req - u.get("messages", 0)
            mb   = pbar(u.get("messages", 0), msg_req)
            msg_line = (f"\n> _ _\n> **ğŸ“‹ Ğ”Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸:**\n"
                        f"> [{mb}] {u.get('messages',0)}/{msg_req} Â· Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ **{need}**")
        desc = (f"> **â­ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ:** {lvl} / {MAX_LEVEL}\n"
                f"> **âœ¨ XP:** {xp:,} _(Ğ´Ğ¾ {lvl+1} Ğ»Ğ²Ğ»: {nxt:,} xp)_\n> [{bar}]\n> _ _\n"
                f"> **ğŸ’° ĞœĞ¾Ğ½ĞµÑ‚Ñ‹:** {u.get('coins',0):,}\n"
                f"> **ğŸ’¬ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹:** {u.get('messages',0):,}\n> _ _\n"
                f"> **ğŸ° Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ:** {g_line}\n"
                f"> **ğŸ–ï¸ Ğ Ğ°Ğ½Ğ³:** {rank_icon(u.get('guild_rank',''))} "
                f"{(u.get('guild_rank') or 'â€”').capitalize()}{msg_line}")
        e = ce(f"ğŸ‘¤ {target.display_name}", desc, ctx.guild)
        if target.display_avatar:
            e.set_thumbnail(url=target.display_avatar.url)
        await ctx.send(embed=e)

    @commands.command(name="balance", aliases=["bal", "coins"])
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def balance(self, ctx: commands.Context, member: disnake.Member = None):
        t = member or ctx.author
        u = get_user(str(t.id), str(ctx.guild.id))
        await ctx.send(embed=ce("ğŸ’° Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                                 f"> **{t.display_name}**\n> _ _\n"
                                 f"> ğŸ’° **{u.get('coins',0):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                                 f"> â­ **{u.get('xp',0):,}** XP (ÑƒÑ€. {u.get('level',1)})\n"
                                 f"> ğŸ’¬ **{u.get('messages',0):,}** ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹", ctx.guild))

    @commands.command(name="daily")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def daily(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        now = datetime.utcnow()
        if u.get("daily_last"):
            try:
                diff = now - datetime.fromisoformat(u["daily_last"])
                if diff.total_seconds() < DAILY_COOLDOWN_H * 3600:
                    rem = timedelta(hours=DAILY_COOLDOWN_H) - diff
                    h   = int(rem.total_seconds() // 3600)
                    m   = int((rem.total_seconds() % 3600) // 60)
                    await ctx.send(embed=ce("Daily",
                                            f"> â° Ğ£Ğ¶Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»!\n> Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ñ‡ĞµÑ€ĞµĞ·: **{h}Ñ‡ {m}Ğ¼**",
                                            ctx.guild, 0xFF8800))
                    return
            except Exception:
                pass
        bonus = DAILY_COINS + random.randint(0, 100)
        new_co = u.get("coins", 0) + bonus
        save_user(uid, sid, {"coins": new_co, "daily_last": now.isoformat()})
        await ctx.send(embed=ce("ğŸ Daily Bonus!",
                                 f"> {ctx.author.mention} Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ!\n> _ _\n"
                                 f"> ğŸ’° **+{bonus} Ğ¼Ğ¾Ğ½ĞµÑ‚**\n> _ _\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_co:,}**", ctx.guild))

    @commands.command(name="work")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def work(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        now = datetime.utcnow()
        if u.get("work_last"):
            try:
                diff = now - datetime.fromisoformat(u["work_last"])
                if diff.total_seconds() < WORK_COOLDOWN_MIN * 60:
                    rem = timedelta(minutes=WORK_COOLDOWN_MIN) - diff
                    m   = int(rem.total_seconds() // 60)
                    await ctx.send(embed=ce("Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°", f"> â° Ğ£ÑÑ‚Ğ°Ğ»! ĞÑ‚Ğ´Ğ¾Ñ…Ğ½Ğ¸ ĞµÑ‰Ñ‘ **{m} Ğ¼Ğ¸Ğ½.**",
                                            ctx.guild, 0xFF8800))
                    return
            except Exception:
                pass
        jobs = [
            ("ğŸŒ¸ Ğ£ĞºÑ€Ğ°ÑĞ¸Ğ» Ğ¿Ğ°Ñ€Ğº Ñ†Ğ²ĞµÑ‚Ğ°Ğ¼Ğ¸", 50, 150), ("ğŸ¨ ĞĞ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ğ» ĞºĞ°Ñ€Ñ‚Ğ¸Ğ½Ñƒ", 80, 200),
            ("ğŸ§¹ ĞĞ°Ğ²Ñ‘Ğ» Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", 40, 120), ("ğŸ° Ğ˜ÑĞ¿Ñ‘Ğº Ñ‚Ğ¾Ñ€Ñ‚", 60, 180),
            ("ğŸµ Ğ’Ñ‹ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ½Ğ° Ğ¿Ğ»Ğ¾Ñ‰Ğ°Ğ´Ğ¸", 70, 160), ("ğŸ“¦ Ğ Ğ°Ğ·Ğ²Ñ‘Ğ· Ğ¿Ğ¾ÑÑ‹Ğ»ĞºĞ¸", 45, 130),
            ("ğŸŒ¿ Ğ¡Ğ¾Ğ±Ñ€Ğ°Ğ» ÑƒÑ€Ğ¾Ğ¶Ğ°Ğ¹", 55, 145), ("ğŸ”¨ ĞŸĞ¾Ñ‡Ğ¸Ğ½Ğ¸Ğ» Ğ·Ğ°Ğ±Ğ¾Ñ€", 35, 110),
            ("ğŸ¾ Ğ’Ñ‹Ğ³ÑƒĞ»ÑĞ» Ğ¿Ğ¸Ñ‚Ğ¾Ğ¼Ñ†ĞµĞ²", 30, 100), ("ğŸ“š ĞŸĞ¾Ğ¼Ğ¾Ğ³ Ñ ÑƒÑ€Ğ¾ĞºĞ°Ğ¼Ğ¸", 40, 120),
        ]
        job, mn, mx = random.choice(jobs)
        earned = random.randint(mn, mx)
        new_co = u.get("coins", 0) + earned
        save_user(uid, sid, {"coins": new_co, "work_last": now.isoformat()})
        await ctx.send(embed=ce("ğŸ’¼ Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°",
                                 f"> {job}\n> _ _\n> ğŸ’° **+{earned} Ğ¼Ğ¾Ğ½ĞµÑ‚**\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_co:,}**",
                                 ctx.guild))

    @commands.command(name="pay")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def pay(self, ctx: commands.Context, member: disnake.Member, amount: int):
        if member.id == ctx.author.id or member.bot:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ!**", ctx.guild, 0xFF0000))
            return
        if amount <= 0:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´", "> **âŒ Ğ¡ÑƒĞ¼Ğ¼Ğ° > 0**", ctx.guild, 0xFF0000))
            return
        uid, tid, sid = str(ctx.author.id), str(member.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if u.get("coins", 0) < amount:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´",
                                     f"> **âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚!** Ğ£ Ñ‚ĞµĞ±Ñ: **{u.get('coins',0):,}**",
                                     ctx.guild, 0xFF0000))
            return
        t = get_user(tid, sid)
        save_user(uid, sid, {"coins": u.get("coins", 0) - amount})
        save_user(tid, sid, {"coins": t.get("coins", 0) + amount})
        await ctx.send(embed=ce("ğŸ’¸ ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´",
                                 f"> {ctx.author.mention} â†’ {member.mention}\n> _ _\n> **{amount:,} Ğ¼Ğ¾Ğ½ĞµÑ‚**",
                                 ctx.guild))

    @commands.command(name="top", aliases=["leaderboard", "lb"])
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def top(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            us_docs = list(db["users"].find({"server_id": sid}).sort("xp", -1).limit(10))
        except Exception:
            us_docs = []
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        desc = ""
        for i, u in enumerate(us_docs, 1):
            mo   = ctx.guild.get_member(int(u["user_id"]))
            name = mo.display_name if mo else f"ID:{u['user_id']}"
            med  = medals[i - 1] if i <= 3 else f"`#{i}`"
            desc += f"> {med} **{name}** â€” â­ {u.get('xp',0):,} XP ğŸ’° {u.get('coins',0):,}\n"
        await ctx.send(embed=ce("ğŸ† Ğ¢Ğ¾Ğ¿ Ğ¿Ğ¾ XP", desc or "> ĞŸĞ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…", ctx.guild))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ° Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="gcreate")
    @commands.cooldown(*COOLDOWNS["guild_heavy"], commands.BucketType.user)
    async def gcreate(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        msg_req = get_msg_required(sid)
        if u.get("guild_id"):
            await ctx.send(embed=ce("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ",
                                     "> **âŒ Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!** Ğ’Ñ‹Ğ¹Ğ´Ğ¸ Ñ‡ĞµÑ€ĞµĞ· `!gleave`",
                                     ctx.guild, 0xFF0000))
            return
        if u.get("messages", 0) < msg_req:
            need = msg_req - u.get("messages", 0)
            bar  = pbar(u.get("messages", 0), msg_req)
            await ctx.send(embed=ce("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸",
                                     f"> **âŒ ĞÑƒĞ¶Ğ½Ğ¾ {msg_req} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹!**\n"
                                     f"> [{bar}] {u.get('messages',0)}/{msg_req} Â· Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ **{need}**",
                                     ctx.guild, 0xFF8800))
            return
        result = await creation_dialog(ctx, self.bot)
        if not result:
            return
        name, tag, desc, color = result["name"], result["tag"], result["desc"], result["color"]
        try:
            gs = list(db["guilds"].find({"server_id": sid}))
        except Exception:
            gs = []
        for g in gs:
            if g.get("tag") == tag:
                await ctx.send(embed=ce("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ", f"> **âŒ Ğ¢ĞµĞ³ [{tag}] ÑƒĞ¶Ğµ Ğ·Ğ°Ğ½ÑÑ‚!**",
                                         ctx.guild, 0xFF0000))
                return
        gid = str(uuid.uuid4())[:8]
        cat, chs = await build_channels(ctx.guild, name, tag, color, ctx.author)
        
        # ğŸ… Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        guild_role = await create_guild_role(ctx.guild, tag, COLORS[color].get("hex", 0x3498DB))
        guild_role_id = guild_role.id if guild_role else None
        
        save_guild(gid, {
            "id": gid, "server_id": sid, "name": name, "tag": tag,
            "description": desc, "color": color, "owner_id": uid,
            "officers": [], "upgrades": [], "bank": 0, "wins": 0, "losses": 0,
            "category_id": cat.id if cat else None, "channels": chs,
            "guild_role_id": guild_role_id,  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ID Ñ€Ğ¾Ğ»Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
            "created_at": str(datetime.utcnow().date()),
            "level": 1, "level_xp": 0,  # Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹
        })
        
        # Ğ”Ğ°Ñ‘Ğ¼ Ğ»Ğ¸Ğ´ĞµÑ€Ñƒ Ñ€Ğ¾Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        if guild_role:
            try:
                await ctx.author.add_roles(guild_role, reason="Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸")
            except Exception as e:
                print(f"[gcreate] ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ´Ğ°Ñ‚ÑŒ Ñ€Ğ¾Ğ»ÑŒ: {e}")
        
        save_user(uid, sid, {"guild_id": gid, "guild_rank": "owner"})
        try:
            old = ctx.author.display_name
            if old.startswith("[") and "]" in old:
                old = old.split("]", 1)[1].strip()
            await ctx.author.edit(nick=f"[{tag}] {old}"[:32])
        except Exception:
            pass
        ann_id = next((c["id"] for c in chs if c["slug"] == "Ğ°Ğ½Ğ¾Ğ½ÑÑ‹"), None)
        if ann_id:
            ann_ch = ctx.guild.get_channel(ann_id)
            if ann_ch:
                try:
                    await ann_ch.send(embed=disnake.Embed(
                        title=f"ğŸŒ¸ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ [{tag}] {name} Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ°!",
                        description=(f"> **Ğ›Ğ¸Ğ´ĞµÑ€:** {ctx.author.mention}\n"
                                     f"> **ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:** _{desc}_\n> _ _\n"
                                     f"> ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: `!ginvite @ÑĞ·ĞµÑ€`"),
                        color=chex(color)).set_author(name=EMBED_AUTHOR))
                except Exception:
                    pass
        await ctx.send(embed=ge("ğŸ° Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ°!",
                                 f"> **[{tag}] {name}**\n> _{desc}_\n> _ _\n"
                                 f"> ğŸ‘‘ {ctx.author.mention} Â· ğŸ¨ {COLORS[color]['label']}\n"
                                 f"> `!ginvite @ÑĞ·ĞµÑ€` â€” Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ",
                                 get_guild(gid), ctx.guild))

    @commands.command(name="gdelete")
    @commands.cooldown(*COOLDOWNS["super_heavy"], commands.BucketType.user)
    async def gdelete(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if not gd or gd["owner_id"] != uid:
            await ctx.send(embed=ce("Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ!**",
                                     ctx.guild, 0xFF0000))
            return
        await ctx.send(embed=ce("âš ï¸ Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ",
                                 f"> Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ **[{gd['tag']}] {gd['name']}**?\n"
                                 "> ĞĞ°Ğ¿Ğ¸ÑˆĞ¸ `Ğ”Ğ` Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ (60 ÑĞµĞº):", ctx.guild, 0xFF8800))

        def check(m):
            return m.author.id == ctx.author.id and m.channel.id == ctx.channel.id
        try:
            r = await self.bot.wait_for("message", check=check, timeout=60)
        except asyncio.TimeoutError:
            await ctx.send(embed=ce("Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ", "> â° ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.", ctx.guild, 0x888888))
            return
        if r.content.upper() != "Ğ”Ğ":
            await ctx.send(embed=ce("Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ", "> âŒ ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾.", ctx.guild, 0x888888))
            return
        await self._dissolve_guild(ctx.guild, gd, sid)
        await ctx.send(embed=ce("ğŸ’” Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°",
                                 f"> **[{gd['tag']}] {gd['name']}** Ğ±Ñ‹Ğ»Ğ° Ñ€Ğ°ÑĞ¿ÑƒÑ‰ĞµĞ½Ğ°.",
                                 ctx.guild, 0x888888))

    async def _dissolve_guild(self, srv: disnake.Guild, gd: dict, sid: str):
        """Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ Ñ…ĞµĞ»Ğ¿ĞµÑ€: ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ + Ğ²Ñ‹Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²."""
        try:
            if gd.get("category_id"):
                cat = srv.get_channel(int(gd["category_id"]))
                if cat:
                    for ch in list(cat.channels):
                        await _safe_delete(ch)
                    await _safe_delete(cat)
        except Exception:
            pass
        for md in guild_members(gd["id"], sid):
            uid = uid_from_member_doc(md)
            if not uid:
                continue
            save_user(uid, sid, {"guild_id": None, "guild_rank": None})
            try:
                mo = srv.get_member(int(uid))
                if mo and mo.display_name.startswith("["):
                    clean = mo.display_name.split("]", 1)[1].strip()
                    await mo.edit(nick=clean or None)
            except Exception:
                pass
        db["guilds"].delete_one({"id": gd["id"]})

    @commands.command(name="ginfo")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def ginfo(self, ctx: commands.Context, *, args: str = None):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        
        # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹
        show_all = False
        tag = None
        
        if args:
            parts = args.split()
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞµ ÑĞ»Ğ¾Ğ²Ğ¾ Ğ½Ğ° "all"
            if parts[-1].lower() == "all":
                show_all = True
                # Ğ•ÑĞ»Ğ¸ Ğ²ÑÑ‘ Ñ‡Ñ‚Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ ÑÑ‚Ğ¾ "all", Ñ‚Ğ¾ tag = None (Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ)
                tag = " ".join(parts[:-1]) if len(parts) > 1 else None
            else:
                tag = args
        
        if tag is None:
            u = get_user(uid, sid)
            if not u.get("guild_id"):
                await ctx.send(embed=ce("Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ",
                                         "> **âŒ Ğ£ĞºĞ°Ğ¶Ğ¸ Ñ‚ĞµĞ³: `!ginfo <Ñ‚ĞµĞ³>` Ğ¸Ğ»Ğ¸ Ğ²ÑÑ‚ÑƒĞ¿Ğ¸ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ**",
                                         ctx.guild, 0xFF0000))
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ", "> **âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾!**", ctx.guild, 0xFF0000))
            return
        
        # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ»Ğ¸Ğ´ĞµÑ€Ğµ
        owner = ctx.guild.get_member(int(gd["owner_id"]))
        o_name = owner.display_name if owner else f"ID:{gd['owner_id']}"
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµÑ… Ñ‡Ğ»ĞµĞ½Ğ¾Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ´Ğ»Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ Ñ€Ğ°Ğ½Ğ³Ğ°Ğ¼
        all_members_list = guild_members(gd["id"], sid)
        
        # Ğ’Ğ¸Ñ†Ğµ-Ğ»Ğ¸Ğ´ĞµÑ€Ñ‹
        viceowners = [m for m in all_members_list if m.get("guild_rank") == "viceowner"]
        viceowners_text = ""
        limit = 5 if not show_all else len(viceowners)
        for m in viceowners[:limit]:
            mid = uid_from_member_doc(m)
            mo = ctx.guild.get_member(int(mid)) if mid else None
            name = mo.display_name if mo else f"ID:{mid}"
            viceowners_text += f"> ğŸ’ {name}\n"
        viceowners_text = viceowners_text or "> â€”\n"
        if not show_all and len(viceowners) > 5:
            viceowners_text += f"> _(Ğ¸ ĞµÑ‰Ñ‘ {len(viceowners) - 5})_\n"
        
        # ĞÑ„Ğ¸Ñ†ĞµÑ€Ñ‹
        officers = [m for m in all_members_list if m.get("guild_rank") == "officer"]
        officers_text = ""
        limit = 5 if not show_all else len(officers)
        for m in officers[:limit]:
            mid = uid_from_member_doc(m)
            mo = ctx.guild.get_member(int(mid)) if mid else None
            name = mo.display_name if mo else f"ID:{mid}"
            officers_text += f"> ğŸ›¡ï¸ {name}\n"
        officers_text = officers_text or "> â€”\n"
        if not show_all and len(officers) > 5:
            officers_text += f"> _(Ğ¸ ĞµÑ‰Ñ‘ {len(officers) - 5})_\n"
        
        # Ğ›ĞµĞ¹Ñ‚ĞµĞ½Ğ°Ğ½Ñ‚Ñ‹
        mods = [m for m in all_members_list if m.get("guild_rank") == "moderator"]
        mods_text = ""
        limit = 5 if not show_all else len(mods)
        for m in mods[:limit]:
            mid = uid_from_member_doc(m)
            mo = ctx.guild.get_member(int(mid)) if mid else None
            name = mo.display_name if mo else f"ID:{mid}"
            mods_text += f"> ğŸ”¨ {name}\n"
        mods_text = mods_text or "> â€”\n"
        if not show_all and len(mods) > 5:
            mods_text += f"> _(Ğ¸ ĞµÑ‰Ñ‘ {len(mods) - 5})_\n"
        
        cnt  = member_count(gd["id"], sid)
        lim  = member_limit(gd.get("upgrades", []))
        upg  = "".join(f"> {GUILD_UPGRADES[k]['emoji']} {GUILD_UPGRADES[k]['name']}\n"
                       for k in gd.get("upgrades", []) if k in GUILD_UPGRADES) or "> ĞĞµÑ‚ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ²\n"
        desc = (f"> **ğŸŒ¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ:** {gd['name']}\n> **ğŸ·ï¸ Ğ¢ĞµĞ³:** [{gd['tag']}]\n"
                f"> **ğŸ“ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:** _{gd['description']}_\n> _ _\n"
                f"> **ğŸ‘‘ Ğ›Ğ¸Ğ´ĞµÑ€:** {o_name}\n"
                f"> **ğŸ’ Ğ’Ğ¸Ñ†Ğµ-Ğ»Ğ¸Ğ´ĞµÑ€Ñ‹:**\n{viceowners_text}"
                f"> **ğŸ›¡ï¸ ĞÑ„Ğ¸Ñ†ĞµÑ€Ñ‹:**\n{officers_text}"
                f"> **ğŸ”¨ Ğ›ĞµĞ¹Ñ‚ĞµĞ½Ğ°Ğ½Ñ‚Ñ‹:**\n{mods_text}> _ _\n"
                f"> **ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²:** {cnt}/{lim}\n> **ğŸ’° ĞšĞ°Ğ·Ğ½Ğ°:** {gd.get('bank',0):,}\n"
                f"> **âš”ï¸ Ğ‘Ğ¾Ğ¸:** {gd.get('wins',0)}W / {gd.get('losses',0)}L\n> _ _\n"
                f"> **ğŸ¨ Ğ¦Ğ²ĞµÑ‚:** {COLORS.get(gd['color'], COLORS[DEFAULT_COLOR])['label']}\n"
                f"> **â­ ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹:**\n{upg}> ğŸ“… ĞÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ°: {gd.get('created_at','?')}")
        
        embed = ge(f"ğŸ° [{gd['tag']}] {gd['name']}", desc, gd, ctx.guild)
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        try:
            image_bytes = await create_guild_card(gd, sid, ctx.guild)
            file = disnake.File(io.BytesIO(image_bytes), filename=f"guild_{gd['tag']}.png")
            embed.set_image(url=f"attachment://guild_{gd['tag']}.png")
            await ctx.send(file=file, embed=embed)
        except Exception:
            # Ğ•ÑĞ»Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ñ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ĞµĞ¼, Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
            await ctx.send(embed=embed)

    @commands.command(name="glist")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def glist(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            gs = list(db["guilds"].find({"server_id": sid}))
            # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ¼Ğ¾Ñ‰Ğ¸ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ°Ğ·Ğ½Ñ‹
            gs = sorted(gs, key=lambda g: calc_guild_power(g, sid), reverse=True)
        except Exception:
            gs = []
        if not gs:
            await ctx.send(embed=ce("Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", "> **ğŸ˜¢ ĞĞµÑ‚ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹! Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹: `!gcreate`**", ctx.guild))
            return
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        pages, per = [], 6
        for i in range(0, len(gs), per):
            chunk = gs[i:i + per]
            desc = ""
            for j, g in enumerate(chunk, i + 1):
                med = medals[j - 1] if j <= 3 else f"`#{j}`"
                cnt = member_count(g["id"], sid)
                lim = member_limit(g.get("upgrades", []))
                pwr = calc_guild_power(g, sid)
                em  = cat_em(g.get("color", DEFAULT_COLOR))
                desc += (f"> {med} {em} **[{g['tag']}] {g['name']}**\n"
                         f"> ğŸ‘¥ {cnt}/{lim} | âš”ï¸ {g.get('wins',0)}W | ğŸ’ª {pwr:,}\n> _ _\n")
            pages.append(desc)
        total = len(pages)
        pkey  = f"glist:{ctx.guild.id}:{ctx.author.id}:{int(datetime.utcnow().timestamp())}"
        _page_store[pkey] = pages
        _page_store[pkey + ":title"] = "ğŸ“‹ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ ({}/{})"
        row = page_row(ctx.author.id, 0, total, pkey)
        await ctx.send(embed=ce("ğŸ“‹ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ (1/{})".format(total), pages[0], ctx.guild),
                       components=[row] if total > 1 else [])

    @commands.command(name="gmembers")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def gmembers(self, ctx: commands.Context, *, tag: str = None):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        if tag is None:
            u = get_user(uid, sid)
            if not u.get("guild_id"):
                await ctx.send(embed=ce("Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", "> **âŒ Ğ£ĞºĞ°Ğ¶Ğ¸ Ñ‚ĞµĞ³!**", ctx.guild, 0xFF0000))
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸", "> **âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾!**", ctx.guild, 0xFF0000))
            return
        mlist = guild_members(gd["id"], sid)
        desc  = ""
        for md in mlist:
            mid  = uid_from_member_doc(md)
            mo   = ctx.guild.get_member(int(mid)) if mid else None
            name = mo.display_name if mo else f"ID:{mid}"
            desc += f"> {rank_icon(md.get('guild_rank','member'))} **{name}** â€” â­ {md.get('xp',0):,} XP\n"
        cnt = len(mlist)
        lim = member_limit(gd.get("upgrades", []))
        await ctx.send(embed=ge(f"ğŸ‘¥ [{gd['tag']}] {gd['name']} ({cnt}/{lim})",
                                 desc or "> *ĞĞµÑ‚ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²*", gd, ctx.guild))

    async def _send_invite(self, guild, inviter, member, respond_fn, error_fn):
        uid, sid = str(inviter.id), str(guild.id)
        if member.bot or member.id == inviter.id:
            await error_fn(ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ!**", guild, 0xFF0000))
            return
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await error_fn(ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if not gd:
            return
        if uid != gd["owner_id"] and uid not in gd.get("officers", []):
            await error_fn(ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€/Ğ¾Ñ„Ğ¸Ñ†ĞµÑ€Ñ‹ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞ°ÑÑ‚!**", guild, 0xFF0000))
            return
        t = get_user(str(member.id), sid)
        if t.get("guild_id"):
            await error_fn(ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", f"> **âŒ {member.display_name} ÑƒĞ¶Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", guild, 0xFF0000))
            return
        cnt   = member_count(gid, sid)
        limit = member_limit(gd.get("upgrades", []))
        if cnt >= limit:
            await error_fn(ce("ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ", f"> **âŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°!** ({cnt}/{limit})", guild, 0xFF0000))
            return
        row   = invite_row(gid, inviter.id, member.id)
        emb   = ge(f"ğŸŒ¸ ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ² [{gd['tag']}] {gd['name']}",
                    f"> **{inviter.display_name}** Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞ°ĞµÑ‚ Ñ‚ĞµĞ±Ñ!\n> _ _\n"
                    f"> ğŸ“ _{gd['description']}_\n> ğŸ‘¥ {cnt}/{limit}\n> _ _\n> ĞĞ°Ğ¶Ğ¼Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ!",
                    gd, guild)
        dm_sent = False
        try:
            dm = await member.create_dm()
            await dm.send(embed=emb, components=[row])
            dm_sent = True
        except Exception:
            pass
        note = "ğŸ“¬ ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ² Ğ›Ğ¡!" if dm_sent else "âš ï¸ Ğ›Ğ¡ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹ â€” Ğ¾Ñ‚Ğ²ĞµÑ‚ÑŒ Ğ·Ğ´ĞµÑÑŒ:"
        await respond_fn(
            content=member.mention,
            embed=ge(f"ğŸŒ¸ ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ² [{gd['tag']}] {gd['name']}",
                      f"> {inviter.mention} Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞ°ĞµÑ‚ {member.mention}!\n> _{note}_\n> _ _\n"
                      f"> ğŸ“ _{gd['description']}_\n> ğŸ‘¥ {cnt}/{limit}\n> **2 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹** Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ÑŒ!",
                      gd, guild),
            components=[row])

    @commands.command(name="ginvite")
    @commands.cooldown(*COOLDOWNS["guild_heavy"], commands.BucketType.user)
    async def ginvite(self, ctx: commands.Context, member: disnake.Member):
        async def respond_fn(content, embed, components):
            await ctx.send(content=content, embed=embed, components=components)
        async def error_fn(embed):
            await ctx.send(embed=embed)
        await self._send_invite(ctx.guild, ctx.author, member, respond_fn, error_fn)

    @commands.slash_command(name="ginvite", description="ĞŸÑ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ")
    async def ginvite_slash(self, inter: disnake.ApplicationCommandInteraction,
                             member: disnake.Member = commands.Param(description="ĞšĞ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ")):
        await inter.response.defer(ephemeral=False)
        async def respond_fn(content, embed, components):
            await inter.edit_original_response(content=content, embed=embed, components=components)
        async def error_fn(embed):
            await inter.edit_original_response(embed=embed)
        await self._send_invite(inter.guild, inter.author, member, respond_fn, error_fn)

    @commands.command(name="gleave")
    @commands.cooldown(*COOLDOWNS["guild_heavy"], commands.BucketType.user)
    async def gleave(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("Ğ’Ñ‹Ñ…Ğ¾Ğ´", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if not gd:
            return
        if gd["owner_id"] == uid:
            await ctx.send(embed=ce("Ğ’Ñ‹Ñ…Ğ¾Ğ´",
                                     "> **âŒ Ğ›Ğ¸Ğ´ĞµÑ€ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑƒĞ¹Ñ‚Ğ¸!**\n"
                                     "> `!gdelete` â€” ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ | `!gtransfer @ÑĞ·ĞµÑ€` â€” Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ",
                                     ctx.guild, 0xFF0000))
            return
        officers = gd.get("officers", [])
        if uid in officers:
            officers.remove(uid)
            save_guild(gid, {"officers": officers})
        save_user(uid, sid, {"guild_id": None, "guild_rank": None})
        await refresh_access(ctx.guild, gd, ctx.author, remove=True)
        
        # ğŸ… Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        guild_role_id = gd.get("guild_role_id")
        if guild_role_id:
            guild_role = ctx.guild.get_role(guild_role_id)
            if guild_role and guild_role in ctx.author.roles:
                try:
                    await ctx.author.remove_roles(guild_role, reason=f"Ğ’Ñ‹Ñ…Ğ¾Ğ´ Ğ¸Ğ· Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ {gd['tag']}")
                except Exception as e:
                    print(f"[gleave] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ñ€Ğ¾Ğ»Ğ¸: {e}")
        
        try:
            if ctx.author.display_name.startswith("["):
                clean = ctx.author.display_name.split("]", 1)[1].strip()
                await ctx.author.edit(nick=clean or None)
        except Exception:
            pass
        await ctx.send(embed=ce("ğŸ‘‹ Ğ’Ñ‹Ñ…Ğ¾Ğ´",
                                 f"> {ctx.author.mention} Ğ¿Ğ¾ĞºĞ¸Ğ½ÑƒĞ»(Ğ°) **[{gd['tag']}] {gd['name']}**.",
                                 ctx.guild, 0x888888))

    @commands.command(name="gkick")
    @commands.cooldown(*COOLDOWNS["guild_heavy"], commands.BucketType.user)
    async def gkick(self, ctx: commands.Context, member: disnake.Member):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞšĞ¸Ğº", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if uid != gd["owner_id"] and uid not in gd.get("officers", []):
            await ctx.send(embed=ce("ĞšĞ¸Ğº", "> **âŒ ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²!**", ctx.guild, 0xFF0000))
            return
        t_uid = str(member.id)
        t = get_user(t_uid, sid)
        if t.get("guild_id") != gid:
            await ctx.send(embed=ce("ĞšĞ¸Ğº", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² Ğ²Ğ°ÑˆĞµĞ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        if t_uid == gd["owner_id"]:
            await ctx.send(embed=ce("ĞšĞ¸Ğº", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ ĞºĞ¸ĞºĞ½ÑƒÑ‚ÑŒ Ğ»Ğ¸Ğ´ĞµÑ€Ğ°!**", ctx.guild, 0xFF0000))
            return
        officers = gd.get("officers", [])
        if t_uid in officers:
            officers.remove(t_uid)
            save_guild(gid, {"officers": officers})
        save_user(t_uid, sid, {"guild_id": None, "guild_rank": None})
        await refresh_access(ctx.guild, gd, member, remove=True)
        
        # ğŸ… Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        guild_role_id = gd.get("guild_role_id")
        if guild_role_id:
            guild_role = ctx.guild.get_role(guild_role_id)
            if guild_role and guild_role in member.roles:
                try:
                    await member.remove_roles(guild_role, reason=f"ĞšĞ¸Ğº Ğ¸Ğ· Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ {gd['tag']}")
                except Exception as e:
                    print(f"[gkick] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ñ€Ğ¾Ğ»Ğ¸: {e}")
        
        try:
            if member.display_name.startswith("["):
                clean = member.display_name.split("]", 1)[1].strip()
                await member.edit(nick=clean or None)
        except Exception:
            pass
        await ctx.send(embed=ce("ğŸ‘¢ ĞšĞ¸Ğº",
                                 f"> {member.mention} Ğ¸ÑĞºĞ»ÑÑ‡Ñ‘Ğ½(Ğ°) Ğ¸Ğ· **[{gd['tag']}]**.",
                                 ctx.guild, 0xFF4444))

    @commands.command(name="gpromote")
    @commands.cooldown(*COOLDOWNS["rank_ops"], commands.BucketType.user)
    async def gpromote(self, ctx: commands.Context, member: disnake.Member):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if u.get("guild_rank") not in ["owner", "viceowner"]:
            await ctx.send(embed=ce("ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€/Ğ²Ğ¸Ñ†Ğµ-Ğ»Ğ¸Ğ´ĞµÑ€!**", ctx.guild, 0xFF0000))
            return
        t_uid = str(member.id)
        t = get_user(t_uid, sid)
        if t.get("guild_id") != gid:
            await ctx.send(embed=ce("ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² Ğ²Ğ°ÑˆĞµĞ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        ladder = ["recruit", "member", "moderator", "officer", "viceowner", "owner"]
        cur_rank = t.get("guild_rank", "recruit")
        if cur_rank == "owner":
            await ctx.send(embed=ce("ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ", "> **âŒ ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ½Ğ³!**", ctx.guild, 0xFF0000))
            return
        idx = ladder.index(cur_rank) if cur_rank in ladder else 0
        new_rank = ladder[min(idx + 1, len(ladder) - 1)]
        save_user(t_uid, sid, {"guild_rank": new_rank})
        rd = GUILD_RANKS[new_rank]
        await ctx.send(embed=ge("ğŸ”¼ ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ğµ",
                                 f"> {member.mention} â†’ **{rd['icon']} {rd['name']}**!", gd, ctx.guild))

    @commands.command(name="gdemote")
    @commands.cooldown(*COOLDOWNS["rank_ops"], commands.BucketType.user)
    async def gdemote(self, ctx: commands.Context, member: disnake.Member):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞŸĞ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if u.get("guild_rank") not in ["owner", "viceowner"]:
            await ctx.send(embed=ce("ĞŸĞ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€/Ğ²Ğ¸Ñ†Ğµ-Ğ»Ğ¸Ğ´ĞµÑ€!**", ctx.guild, 0xFF0000))
            return
        t_uid = str(member.id)
        t = get_user(t_uid, sid)
        if t.get("guild_id") != gid:
            await ctx.send(embed=ce("ĞŸĞ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² Ğ²Ğ°ÑˆĞµĞ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        ladder = ["recruit", "member", "moderator", "officer", "viceowner", "owner"]
        cur_rank = t.get("guild_rank", "member")
        if cur_rank == "recruit":
            await ctx.send(embed=ce("ĞŸĞ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ", "> **âŒ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ½Ğ³!**", ctx.guild, 0xFF0000))
            return
        idx = ladder.index(cur_rank) if cur_rank in ladder else 1
        new_rank = ladder[max(idx - 1, 0)]
        save_user(t_uid, sid, {"guild_rank": new_rank})
        rd = GUILD_RANKS[new_rank]
        await ctx.send(embed=ge("ğŸ”½ ĞŸĞ¾Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ",
                                 f"> {member.mention} â†’ **{rd['icon']} {rd['name']}**.", gd, ctx.guild))

    @commands.command(name="gtransfer")
    @commands.cooldown(*COOLDOWNS["super_heavy"], commands.BucketType.user)
    async def gtransfer(self, ctx: commands.Context, member: disnake.Member):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if gd["owner_id"] != uid:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ°", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€!**", ctx.guild, 0xFF0000))
            return
        t_uid = str(member.id)
        t = get_user(t_uid, sid)
        if t.get("guild_id") != gid:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ°", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² Ğ²Ğ°ÑˆĞµĞ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        if t_uid == uid:
            await ctx.send(embed=ce("ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ°", "> **âŒ Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ»Ğ¸Ğ´ĞµÑ€!**", ctx.guild, 0xFF0000))
            return
        officers = gd.get("officers", [])
        if t_uid in officers:
            officers.remove(t_uid)
        save_guild(gid, {"owner_id": t_uid, "officers": officers})
        save_user(uid, sid, {"guild_rank": "member"})
        save_user(t_uid, sid, {"guild_rank": "owner"})
        await ctx.send(embed=ge("ğŸ‘‘ ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ»Ğ¸Ğ´ĞµÑ€ÑÑ‚Ğ²Ğ°",
                                 f"> {ctx.author.mention} Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ»(Ğ°) ĞºĞ¾Ñ€Ğ¾Ğ½Ñƒ {member.mention}!\n"
                                 f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ»Ğ¸Ğ´ĞµÑ€: {member.mention}", gd, ctx.guild))

    @commands.command(name="granks")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def granks(self, ctx: commands.Context):
        e = ce("ğŸ“Š Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ Ğ°Ğ½Ğ³Ğ¾Ğ²", "Ğ Ğ°Ğ½Ğ³Ğ¸ Ğ´Ğ°ÑÑ‚ Ğ±Ğ¾Ğ½ÑƒÑÑ‹ Ğº XP Ğ¸ Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ°Ğ¼ Ğ·Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ:", ctx.guild, 0x9370DB)
        for rk in ["recruit", "member", "moderator", "officer", "viceowner", "owner"]:
            rd = GUILD_RANKS.get(rk)
            if rd:
                e.add_field(name=f"{rd['icon']} {rd['name']}",
                            value=f"XP Ã—{rd['xp_bonus']} | ĞœĞ¾Ğ½ĞµÑ‚Ñ‹ Ã—{rd['coin_bonus']}", inline=False)
        await ctx.send(embed=e)

    @commands.command(name="gcolor")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def gcolor(self, ctx: commands.Context, color: str = None):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("Ğ¦Ğ²ĞµÑ‚", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if uid != gd["owner_id"] and uid not in gd.get("officers", []):
            await ctx.send(embed=ce("Ğ¦Ğ²ĞµÑ‚", "> **âŒ ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²!**", ctx.guild, 0xFF0000))
            return
        if not color or color.lower() not in COLORS:
            avail = " | ".join(f"`{k}` {v['label']}" for k, v in COLORS.items())
            await ctx.send(embed=ce("ğŸ¨ Ğ¦Ğ²ĞµÑ‚Ğ°", f"> {avail}\n> `!gcolor <Ñ†Ğ²ĞµÑ‚>`", ctx.guild))
            return
        gd["color"] = color.lower()
        save_guild(gid, {"color": color.lower()})
        owner = ctx.guild.get_member(int(gd["owner_id"])) or ctx.author
        msg = await ctx.send(embed=ce("â³", "> ĞŸĞµÑ€ĞµÑĞ¾Ğ·Ğ´Ğ°Ñ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹...", ctx.guild))
        await rebuild(ctx.guild, gd, owner)
        ci = COLORS[color.lower()]
        await msg.edit(embed=ce("ğŸ¨ Ğ¦Ğ²ĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½!", f"> **[{gd['tag']}]** â†’ {ci['label']}", ctx.guild, ci["hex"]))

    @commands.command(name="gdesc")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def gdesc(self, ctx: commands.Context, *, text: str):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if uid != gd["owner_id"] and uid not in gd.get("officers", []):
            await ctx.send(embed=ce("ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", "> **âŒ ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²!**", ctx.guild, 0xFF0000))
            return
        if len(text) > 100:
            await ctx.send(embed=ce("ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ", "> **âŒ ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 100 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²!**", ctx.guild, 0xFF0000))
            return
        save_guild(gid, {"description": text})
        gd["description"] = text
        await ctx.send(embed=ge("âœï¸ ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾", f"> _{text}_", gd, ctx.guild))

    @commands.command(name="gdeposit", aliases=["gdep"])
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def gdeposit(self, ctx: commands.Context, amount: int):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        if amount <= 0:
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ¡ÑƒĞ¼Ğ¼Ğ° > 0**", ctx.guild, 0xFF0000))
            return
        if u.get("coins", 0) < amount:
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", f"> **âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚!** Ğ£ Ñ‚ĞµĞ±Ñ: {u.get('coins',0):,}",
                                     ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        new_bank = gd.get("bank", 0) + amount
        save_guild(gid, {"bank": new_bank})
        save_user(uid, sid, {"coins": u.get("coins", 0) - amount})
        gd["bank"] = new_bank
        
        # ğŸ“ˆ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ XP Ğ·Ğ° Ğ²ĞºĞ»Ğ°Ğ´ (1 XP Ğ·Ğ° 100 Ğ¼Ğ¾Ğ½ĞµÑ‚)
        xp_gain = amount // 100
        if xp_gain > 0:
            add_guild_xp(gid, xp_gain)
        
        await ctx.send(embed=ge("ğŸ’° Ğ’Ğ·Ğ½Ğ¾Ñ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ",
                                 f"> ğŸ’¸ **+{amount:,}**\n> ğŸ¦ ĞšĞ°Ğ·Ğ½Ğ°: **{new_bank:,}**", gd, ctx.guild))

    @commands.command(name="gwithdraw", aliases=["gwith"])
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def gwithdraw(self, ctx: commands.Context, amount: int):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if gd["owner_id"] != uid:
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€!**", ctx.guild, 0xFF0000))
            return
        if amount <= 0 or gd.get("bank", 0) < amount:
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°",
                                     f"> **âŒ ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ² ĞºĞ°Ğ·Ğ½Ğµ!** {gd.get('bank',0):,}",
                                     ctx.guild, 0xFF0000))
            return
        new_bank = gd.get("bank", 0) - amount
        save_guild(gid, {"bank": new_bank})
        save_user(uid, sid, {"coins": u.get("coins", 0) + amount})
        gd["bank"] = new_bank
        await ctx.send(embed=ge("ğŸ’¸ Ğ’Ñ‹Ğ²Ğ¾Ğ´", f"> **-{amount:,}**\n> ĞšĞ°Ğ·Ğ½Ğ°: **{new_bank:,}**", gd, ctx.guild))

    @commands.command(name="gupgrade")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def gupgrade(self, ctx: commands.Context, upg_id: str = None):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if not upg_id:
            desc = "> **Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹:**\n> _ _\n"
            for k, upg in GUILD_UPGRADES.items():
                owned = " âœ…" if k in gd.get("upgrades", []) else ""
                desc += f"> {upg['emoji']} **{upg['name']}**{owned} â€” {upg['price']:,} | ID:`{k}`\n> _ _\n"
            desc += f"> ğŸ’° **ĞšĞ°Ğ·Ğ½Ğ°:** {gd.get('bank',0):,}\n> ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: `!gupgrade slot_1`"
            await ctx.send(embed=ge("â­ ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹", desc, gd, ctx.guild))
            return
        if uid != gd["owner_id"] and uid not in gd.get("officers", []):
            await ctx.send(embed=ce("ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹", "> **âŒ ĞĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²!**", ctx.guild, 0xFF0000))
            return
        if upg_id not in GUILD_UPGRADES:
            await ctx.send(embed=ce("ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹", f"> **âŒ `{upg_id}` Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!**", ctx.guild, 0xFF0000))
            return
        if upg_id in gd.get("upgrades", []):
            await ctx.send(embed=ce("ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹", "> **âŒ Ğ£Ğ¶Ğµ ĞºÑƒĞ¿Ğ»ĞµĞ½!**", ctx.guild, 0xFF0000))
            return
        upg  = GUILD_UPGRADES[upg_id]
        bank = gd.get("bank", 0)
        if bank < upg["price"]:
            await ctx.send(embed=ce("ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹",
                                     f"> **âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚!** ĞšĞ°Ğ·Ğ½Ğ°: {bank:,} | ĞÑƒĞ¶Ğ½Ğ¾: {upg['price']:,}",
                                     ctx.guild, 0xFF0000))
            return
        new_bank = bank - upg["price"]
        upgrades = gd.get("upgrades", []) + [upg_id]
        save_guild(gid, {"bank": new_bank, "upgrades": upgrades})
        gd["bank"] = new_bank
        gd["upgrades"] = upgrades
        
        # ğŸ“ˆ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ XP Ğ·Ğ° Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´ (200 XP Ğ·Ğ° Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´)
        add_guild_xp(gid, 200)
        
        await ctx.send(embed=ge("â­ ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´ ĞºÑƒĞ¿Ğ»ĞµĞ½!",
                                 f"> {upg['emoji']} **{upg['name']}**\n> ĞšĞ°Ğ·Ğ½Ğ°: **{new_bank:,}**", gd, ctx.guild))

    @commands.command(name="gbank", aliases=["gvault", "gcashbox"])
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def gbank(self, ctx: commands.Context, *, tag: str = None):
        """ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ĞºĞ°Ğ·Ğ½Ñ‹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¾Ğ¹"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        
        if tag is None:
            if not u.get("guild_id"):
                await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**\n> Ğ£ĞºĞ°Ğ¶Ğ¸ Ñ‚ĞµĞ³: `!gbank <Ñ‚ĞµĞ³>`",
                                        ctx.guild, 0xFF0000))
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        
        if not gd:
            await ctx.send(embed=ce("ĞšĞ°Ğ·Ğ½Ğ°", "> **âŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        
        bank = gd.get("bank", 0)
        members = guild_members(gd["id"], sid)
        member_count_val = len(members)
        wins = gd.get("wins", 0)
        losses = gd.get("losses", 0)
        
        # Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ¾Ñ…Ğ¾Ğ´ Ñ‡Ğ»ĞµĞ½Ğ¾Ğ² Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼
        total_member_income = 0
        if INCOME_SOURCES:
            for member in members:
                farms = member.get("farms", [])
                member_income = get_income_per_hour(farms, gd.get("upgrades", []))
                total_member_income += member_income
        
        # Ğ‘Ğ¾Ğ½ÑƒÑÑ‹
        vault_bonus = get_guild_vault_bonus(gd.get("upgrades", []))
        income_bonus_pct = 0
        for upg_key in gd.get("upgrades", []):
            if upg_key in GUILD_INCOME_UPGRADES:
                upg = GUILD_INCOME_UPGRADES[upg_key]
                if "bonus_percent" in upg and "contribution_bonus_percent" not in upg:
                    income_bonus_pct = max(income_bonus_pct, upg["bonus_percent"])
        
        desc = (f"> **ğŸ’° ĞšĞĞ—ĞĞ:** {bank:,} Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n"
                f"> **ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²:** {member_count_val}\n"
                f"> **âš”ï¸ Ğ ĞµĞºĞ¾Ñ€Ğ´:** {wins}W / {losses}L\n> _ _\n")
        
        if total_member_income > 0:
            daily_income = total_member_income * 24 * member_count_val
            desc += (f"> **ğŸŒ¾ Ğ”ĞĞ¥ĞĞ” ĞĞ¢ Ğ¤Ğ•Ğ Ğœ:**\n"
                    f"> â€¢ ĞŸĞ¾ Ñ‡Ğ°ÑĞ°Ğ¼: +{total_member_income:,}/Ñ‡ (Ğ²ÑĞµ Ñ‡Ğ»ĞµĞ½Ñ‹)\n"
                    f"> â€¢ Ğ’ Ğ´ĞµĞ½ÑŒ: ~+{daily_income:,}/Ğ´ĞµĞ½ÑŒ\n> _ _\n")
        
        if gd.get("upgrades"):
            upg_text = ""
            for upg_key in gd.get("upgrades", []):
                if upg_key in GUILD_UPGRADES:
                    upg = GUILD_UPGRADES[upg_key]
                    upg_text += f"> {upg['emoji']} {upg['name']}\n"
            if upg_text:
                desc += f"> **â­ ĞĞŸĞ“Ğ Ğ•Ğ™Ğ”Ğ«:**\n{upg_text}> _ _\n"
        
        if total_member_income > 0 or income_bonus_pct > 0:
            desc += f"> **ğŸ“ˆ Ğ‘ĞĞĞ£Ğ¡Ğ«:**\n> â€¢ Ğ”Ğ¾Ñ…Ğ¾Ğ´ Ñ‡Ğ»ĞµĞ½Ğ¾Ğ²: +{income_bonus_pct}%\n> â€¢ Ğ’Ğ·Ğ½Ğ¾Ñ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ: +{(vault_bonus-1)*100:.0f}%\n> _ _\n"
        
        desc += f"> **ğŸ’¡ Ğ¡Ğ¾Ğ²ĞµÑ‚:** Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!gupgrade` Ğ´Ğ»Ñ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ"
        
        await ctx.send(embed=ge(f"ğŸ¦ ĞšĞ°Ğ·Ğ½Ğ° [{gd['tag']}] {gd['name']}", desc, gd, ctx.guild))

    @commands.command(name="geconomy", aliases=["gecon", "gstas"])
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def geconomy(self, ctx: commands.Context, *, tag: str = None):
        """ĞŸĞ¾Ğ»Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        
        if tag is None:
            if not u.get("guild_id"):
                await ctx.send(embed=ce("Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                        ctx.guild, 0xFF0000))
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        
        if not gd:
            await ctx.send(embed=ce("Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ°", "> **âŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        
        members = guild_members(gd["id"], sid)
        
        # ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‡Ğ»ĞµĞ½Ğ¾Ğ² Ğ¿Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ¸ Ñ„ĞµÑ€Ğ¼
        member_stats = []
        total_member_xp = 0
        total_member_coins = 0
        total_farms = 0
        total_member_income = 0
        
        for member in members:
            xp = member.get("xp", 0)
            coins = member.get("coins", 0)
            lvl = member.get("level", 1)
            farms = member.get("farms", [])
            
            total_member_xp += xp
            total_member_coins += coins
            total_farms += len(farms)
            
            if INCOME_SOURCES:
                member_income = get_income_per_hour(farms, gd.get("upgrades", []))
                total_member_income += member_income
        
        avg_lvl = sum(m.get("level", 1) for m in members) / max(1, len(members))
        
        bank = gd.get("bank", 0)
        total_assets = bank + total_member_coins
        
        desc = (f"> **ğŸ’° Ğ¤Ğ˜ĞĞĞĞ¡ĞĞ’Ğ«Ğ™ ĞĞ¢Ğ§Ğ•Ğ¢:**\n"
                f"> â€¢ ĞšĞ°Ğ·Ğ½Ğ°: **{bank:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                f"> â€¢ Ğ£ Ñ‡Ğ»ĞµĞ½Ğ¾Ğ²: ~**{total_member_coins:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                f"> â€¢ **Ğ’ÑĞµĞ³Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¾Ğ²: {total_assets:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n"
                f"> **ğŸ‘¥ Ğ§Ğ›Ğ•ĞĞ«:**\n"
                f"> â€¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: **{len(members)}** /(15-50)\n"
                f"> â€¢ Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ ÑƒÑ€.: **{avg_lvl:.1f}**\n"
                f"> â€¢ ĞĞ±Ñ‰Ğ¸Ğ¹ XP: **{total_member_xp:,}**\n> _ _\n")
        
        if INCOME_SOURCES and total_farms > 0:
            daily_passive = total_member_income * 24
            hourly_contribution = int(total_member_income * 0.01)  # 1% Ğ² ĞºĞ°Ğ·Ğ½Ñƒ
            monthly_passive = daily_passive * 30
            desc += (f"> **ğŸŒ¾ ĞŸĞĞ¡Ğ¡Ğ˜Ğ’ĞĞ«Ğ™ Ğ”ĞĞ¥ĞĞ”:**\n"
                    f"> â€¢ Ğ¤ĞµÑ€Ğ¼ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾: **{total_farms}**\n"
                    f"> â€¢ Ğ’ Ñ‡Ğ°Ñ: **{total_member_income:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ’ Ğ´ĞµĞ½ÑŒ: **{daily_passive:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ’ Ğ¼ĞµÑÑÑ†: **~{monthly_passive:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ’ ĞºĞ°Ğ·Ğ½Ñƒ/Ñ‡Ğ°Ñ: **~{hourly_contribution:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n")
        
        # ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹
        if gd.get("upgrades"):
            upg_cost = sum(GUILD_UPGRADES.get(upg_key, {}).get("price", 0) for upg_key in gd.get("upgrades", []))
            income_bonus = 0
            for upg_key in gd.get("upgrades", []):
                if upg_key in GUILD_INCOME_UPGRADES:
                    upg_data = GUILD_INCOME_UPGRADES[upg_key]
                    if "bonus_percent" in upg_data and "contribution_bonus_percent" not in upg_data:
                        income_bonus = max(income_bonus, upg_data["bonus_percent"])
            
            desc += (f"> **â­ Ğ˜ĞĞ’Ğ•Ğ¡Ğ¢Ğ˜Ğ¦Ğ˜Ğ˜:**\n"
                    f"> â€¢ ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ² ĞºÑƒĞ¿Ğ»ĞµĞ½Ğ¾: **{len(gd.get('upgrades', []))}**\n"
                    f"> â€¢ Ğ’Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¾ Ğ²ÑĞµĞ³Ğ¾: **{upg_cost:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ‘Ğ¾Ğ½ÑƒÑ Ğ´Ğ¾Ñ…Ğ¾Ğ´Ñƒ: **+{income_bonus}%**\n> _ _\n")
        
        # ĞÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ°
        next_upg = None
        for upg_id, upg in GUILD_UPGRADES.items():
            if upg_id not in gd.get("upgrades", []):
                next_upg = (upg_id, upg)
                break
        
        if next_upg:
            desc += (f"> **ğŸ¯ Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ®Ğ©Ğ˜Ğ™ ĞĞŸĞ“Ğ Ğ•Ğ™Ğ”:**\n"
                    f"> {next_upg[1]['emoji']} **{next_upg[1]['name']}**\n"
                    f"> Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{next_upg[1]['price']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> ĞÑƒĞ¶Ğ½Ñ‹ ĞµÑ‰Ğµ: **{max(0, next_upg[1]['price'] - bank):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚")
        else:
            desc += "> **âœ… Ğ’ÑĞµ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹ ĞºÑƒĞ¿Ğ»ĞµĞ½Ñ‹! Ğ’Ñ‹ Ğ»ĞµĞ³ĞµĞ½Ğ´Ñ‹! ğŸ†**"
        
        await ctx.send(embed=ge(f"ğŸ“Š Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸ĞºĞ° [{gd['tag']}]", desc, gd, ctx.guild))

    @commands.command(name="gmyincome")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def gmyincome(self, ctx: commands.Context):
        """Ğ¢Ğ²Ğ¾Ğ¹ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´ Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼"""
        if not INCOME_SOURCES:
            await ctx.send(embed=ce("Ğ”Ğ¾Ñ…Ğ¾Ğ´", "> **âŒ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ„ĞµÑ€Ğ¼ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°**", ctx.guild, 0xFF0000))
            return
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        farms = u.get("farms", [])
        
        if not farms:
            await ctx.send(embed=ce("ğŸŒ¾ ĞœĞ¾Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´", "> **âŒ Ğ£ Ñ‚ĞµĞ±Ñ Ğ½ĞµÑ‚ Ñ„ĞµÑ€Ğ¼!**\n> ĞšÑƒĞ¿Ğ¸: `!buyfarm`",
                                    ctx.guild, 0xFF8800))
            return
        
        gd = get_guild(u.get("guild_id")) if u.get("guild_id") else None
        guild_upgrades = gd.get("upgrades", []) if gd else []
        
        hourly = get_income_per_hour(farms, guild_upgrades)
        daily = hourly * 24
        monthly = daily * 30
        
        vault_bonus = get_guild_vault_bonus(guild_upgrades) if gd else 1.0
        guild_contribution = int(hourly * 0.01) if gd else 0
        player_gets = hourly - guild_contribution
        
        desc = (f"> **â° Ğ¢Ğ’ĞĞ™ ĞŸĞĞ¡Ğ¡Ğ˜Ğ’ĞĞ«Ğ™ Ğ”ĞĞ¥ĞĞ”:**\n> _ _\n"
                f"> ğŸŒ¾ Ğ’ÑĞµĞ³Ğ¾ Ñ„ĞµÑ€Ğ¼: **{len(farms)}**\n"
                f"> ğŸ“ˆ Ğ”Ğ¾Ñ…Ğ¾Ğ´ Ğ² Ñ‡Ğ°Ñ: **{hourly:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n"
                f"> **Ğ‘ĞµĞ· Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ²:**\n"
                f"> â€¢ Ğ’ Ğ´ĞµĞ½ÑŒ: **{daily:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                f"> â€¢ Ğ’ Ğ¼ĞµÑÑÑ†: **~{monthly:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n")
        
        if gd:
            daily_with_contribution = (player_gets * 24) if guild_contribution > 0 else daily
            monthly_with_contribution = daily_with_contribution * 30
            desc += (f"> **Ğ¡ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ Ğ²Ğ·Ğ½Ğ¾ÑĞ¾Ğ² Ğ² ĞºĞ°Ğ·Ğ½Ñƒ:**\n"
                    f"> â€¢ Ğ¢ĞµĞ±Ğµ Ğ·Ğ° Ñ‡Ğ°Ñ: **{player_gets:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ’ ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸: **{guild_contribution:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ¢ĞµĞ±Ğµ Ğ² Ğ´ĞµĞ½ÑŒ: **{player_gets * 24:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                    f"> â€¢ Ğ¢ĞµĞ±Ğµ Ğ² Ğ¼ĞµÑÑÑ†: **~{player_gets * 24 * 30:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n"
                    f"> ğŸ’¡ Ğ‘Ğ¾Ğ½ÑƒÑ ĞºĞ°Ğ·Ğ½Ñ‹: **+{(vault_bonus-1)*100:.0f}%**")
        
        await ctx.send(embed=ce("ğŸŒ¾ Ğ¢Ğ²Ğ¾Ğ¹ Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="gwar")
    @commands.cooldown(*COOLDOWNS["wars"], commands.BucketType.user)
    async def gwar(self, ctx: commands.Context, *, tag: str):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("Ğ’Ğ¾Ğ¹Ğ½Ğ°", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if gd["owner_id"] != uid:
            await ctx.send(embed=ce("Ğ’Ğ¾Ğ¹Ğ½Ğ°", "> **âŒ Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€ Ğ¾Ğ±ÑŠÑĞ²Ğ»ÑĞµÑ‚ Ğ²Ğ¾Ğ¹Ğ½Ñƒ!**", ctx.guild, 0xFF0000))
            return
        enemy = guild_by_tag(sid, tag)
        if not enemy:
            await ctx.send(embed=ce("Ğ’Ğ¾Ğ¹Ğ½Ğ°", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        if enemy["id"] == gid:
            await ctx.send(embed=ce("Ğ’Ğ¾Ğ¹Ğ½Ğ°", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ Ğ²Ğ¾ĞµĞ²Ğ°Ñ‚ÑŒ Ñ ÑĞ¾Ğ±Ğ¾Ğ¹!**", ctx.guild, 0xFF0000))
            return
        
        # âš”ï¸ Ğ£Ğ›Ğ£Ğ§Ğ¨Ğ•ĞĞĞ«Ğ™ Ğ ĞĞ¡Ğ§Ğ•Ğ¢ ĞœĞĞ©Ğ˜
        my_members = member_count(gid, sid)
        en_members = member_count(enemy["id"], sid)
        
        my_base = gd.get("bank", 0) + my_members * 1000
        en_base = enemy.get("bank", 0) + en_members * 1000
        
        my_p = my_base + random.randint(-2000, 5000)
        en_p = en_base + random.randint(-2000, 5000)
        
        # Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ´Ğ»Ñ Ğ±Ğ¾Ñ
        my_emoji = "ğŸŒ¸"
        en_emoji = "âš”ï¸"
        
        # ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ±Ğ¾Ñ
        wmsg = await ctx.send(embed=ce("ğŸŒ¸ Ğ’ĞĞ™ĞĞ Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ™! âš”ï¸",
                                        f"> **[{gd['tag']}] {gd['name']}** ({my_members} Ñ‡ĞµĞ»)\n"
                                        f"> vs\n"
                                        f"> **[{enemy['tag']}] {enemy['name']}** ({en_members} Ñ‡ĞµĞ»)\n"
                                        f"> _ _\n"
                                        f"> ğŸ–ï¸ ĞœĞ¾Ñ‰ÑŒ:\n"
                                        f"> {my_emoji} {my_p:,} | {en_emoji} {en_p:,}\n"
                                        f"> _ _\n> âš¡ Ğ‘Ğ¾ĞµĞ²Ñ‹Ğµ Ñ€Ğ°ÑƒĞ½Ğ´Ñ‹...", ctx.guild, 0xFF6B9D))
        
        # ğŸ­ Ğ‘ĞĞ•Ğ’Ğ«Ğ• Ğ ĞĞ£ĞĞ”Ğ«
        my_hp = 100
        en_hp = 100
        round_num = 1
        
        for _ in range(5):
            await asyncio.sleep(2)
            
            # Ğ£Ñ€Ğ¾Ğ½ Ğ² ÑÑ‚Ğ¾Ğ¼ Ñ€Ğ°ÑƒĞ½Ğ´Ğµ
            my_dmg = random.randint(int(my_p * 0.2), int(my_p * 0.4))
            en_dmg = random.randint(int(en_p * 0.2), int(en_p * 0.4))
            
            my_hp = max(0, my_hp - en_dmg // 1000)
            en_hp = max(0, en_hp - my_dmg // 1000)
            
            # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°ÑƒĞ½Ğ´
            round_text = (
                f"> **ğŸ“ Ğ Ğ°ÑƒĞ½Ğ´ {round_num}/5**\n> _ _\n"
                f"> {my_emoji} [{gd['tag']}] HP: {my_hp}/100\n"
                f"> {en_emoji} [{enemy['tag']}] HP: {en_hp}/100\n"
                f"> _ _\n"
                f"> ğŸ’¥ Ğ£Ñ€Ğ¾Ğ½: {my_dmg:,} â†”ï¸ {en_dmg:,}"
            )
            
            await wmsg.edit(embed=ce("ğŸŒ¸ Ğ‘ĞĞ™ Ğ˜Ğ”Ğ•Ğ¢! âš”ï¸", round_text, ctx.guild, 0xFF6B9D))
            round_num += 1
            
            if my_hp <= 0 or en_hp <= 0:
                break
        
        # ğŸ† Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢
        winner = gd if en_hp <= 0 else enemy
        loser = enemy if en_hp <= 0 else gd
        
        prize = min(loser.get("bank", 0) // 5, 25_000)
        
        save_guild(winner["id"], {
            "bank": winner.get("bank", 0) + prize, 
            "wins": winner.get("wins", 0) + 1
        })
        save_guild(loser["id"], {
            "bank": max(0, loser.get("bank", 0) - prize), 
            "losses": loser.get("losses", 0) + 1
        })
        
        # ğŸ“ˆ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ XP Ğ·Ğ° Ğ¿Ğ¾Ğ±ĞµĞ´Ñƒ
        add_guild_xp(winner["id"], 500)  # ĞŸĞ¾Ğ±ĞµĞ´Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ 500 XP
        add_guild_xp(loser["id"], 100)   # ĞŸÑ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ğ²ÑˆĞ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ 100 XP Ğ·Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ¸Ğµ
        
        wr = get_guild(winner["id"])
        lr = get_guild(loser["id"])
        
        result_text = (
            f"> ğŸ† **ĞŸĞĞ‘Ğ•Ğ”Ğ˜Ğ¢Ğ•Ğ›Ğ¬: [{winner['tag']}] {winner['name']}!**\n"
            f"> _ _\n"
            f"> ğŸ’° Ğ¢Ñ€Ğ¾Ñ„ĞµĞ¹: **+{prize:,} Ğ¼Ğ¾Ğ½ĞµÑ‚**\n"
            f"> ğŸ’€ ĞŸĞ¾Ñ‚ĞµÑ€Ñ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸ĞºĞ°: **-{prize:,} Ğ¼Ğ¾Ğ½ĞµÑ‚**\n"
            f"> _ _\n"
            f"> ğŸ“Š **Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:**\n"
            f"> ğŸ¥‡ [{winner['tag']}]: {wr.get('wins', 0)} Ğ¿Ğ¾Ğ±ĞµĞ´\n"
            f"> â˜ ï¸ [{loser['tag']}]: {lr.get('losses', 0)} Ğ¿Ğ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹"
        )
        
        await wmsg.edit(embed=ce(
            "ğŸŒ¸ Ğ’ĞĞ™ĞĞ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ! âš”ï¸" if winner == gd else "âš”ï¸ Ğ’ĞĞ™ĞĞ Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ! ğŸŒ¸",
            result_text, ctx.guild, 0xFFD700))

    @commands.command(name="gstats")
    async def gstats(self, ctx: commands.Context, *, tag: str = None):
        """ğŸ“Š ĞŸĞ¾Ğ»Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        if tag is None:
            u = get_user(uid, sid)
            if not u.get("guild_id"):
                await ctx.send(embed=ce("ğŸ“Š", "> **âŒ Ğ£ĞºĞ°Ğ¶Ğ¸ Ñ‚ĞµĞ³ Ğ¸Ğ»Ğ¸ ÑĞ¾ÑÑ‚Ğ¾Ğ¹ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000), delete_after=10)
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        
        if not gd:
            await ctx.send(embed=ce("ğŸ“Š", f"> **âŒ [{tag.upper() if tag else '?'}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        cnt = member_count(gd["id"], sid)
        lim = member_limit(gd.get("upgrades", []))
        pwr = calc_guild_power(gd, sid)
        
        desc = (
            f"> ğŸ“› **ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ:** {gd['name']}\n"
            f"> ğŸ·ï¸ **Ğ¢ĞµĞ³:** [{gd['tag']}]\n"
            f"> ğŸ‘‘ **Ğ›Ğ¸Ğ´ĞµÑ€:** <@{gd['owner_id']}>\n"
            f"> _ _\n"
            f"> ğŸ‘¥ **Ğ§Ğ»ĞµĞ½Ñ‹:** {cnt}/{lim}\n"
            f"> ğŸ’° **ĞšĞ°Ğ·Ğ½Ğ°:** {gd.get('bank', 0):,}\n"
            f"> ğŸ’ª **ĞœĞ¾Ñ‰ÑŒ:** {pwr:,}\n"
            f"> _ _\n"
            f"> ğŸ† **ĞŸĞ¾Ğ±ĞµĞ´:** {gd.get('wins', 0)}\n"
            f"> ğŸ’€ **ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹:** {gd.get('losses', 0)}\n"
            f"> ğŸ”§ **ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ²:** {len(gd.get('upgrades', []))}\n"
            f"> _ _\n"
            f"> ğŸ“ **ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:** {gd.get('description', 'ĞĞµÑ‚')}"
        )
        
        embed = disnake.Embed(title=f"ğŸ“Š [{gd['tag']}] {gd['name']} â€” Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", 
                              description=desc, color=COLORS.get(gd.get("color"), COLORS[DEFAULT_COLOR]).get("hex", 0xFF69B4))
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        try:
            image_bytes = await create_guild_card(gd, sid, ctx.guild)
            file = disnake.File(io.BytesIO(image_bytes), filename=f"guild_{gd['tag']}.png")
            embed.set_image(url=f"attachment://guild_{gd['tag']}.png")
            await ctx.send(file=file, embed=embed)
        except Exception:
            # Ğ•ÑĞ»Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ñ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ĞµĞ¼, Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚ĞµĞºÑÑ‚
            await ctx.send(embed=embed)

    @commands.command(name="granking")
    async def granking(self, ctx: commands.Context, sort_by: str = "power"):
        """ğŸ… Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼: power|wins|members|bank"""
        sid = str(ctx.guild.id)
        try:
            gs = list(db["guilds"].find({"server_id": sid}))
        except Exception:
            gs = []
        
        if not gs:
            await ctx.send(embed=ce("ğŸ…", "> **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ½ĞµÑ‚!**", ctx.guild), delete_after=10)
            return
        
        sort_by = sort_by.lower()
        if sort_by == "power":
            gs = sorted(gs, key=lambda g: calc_guild_power(g, sid), reverse=True)
            title_sort = "ğŸ’ª ĞŸĞ¾ ĞœĞ¾Ñ‰Ğ¸"
        elif sort_by == "wins":
            gs = sorted(gs, key=lambda g: g.get("wins", 0), reverse=True)
            title_sort = "ğŸ† ĞŸĞ¾ ĞŸĞ¾Ğ±ĞµĞ´Ğ°Ğ¼"
        elif sort_by == "members":
            gs = sorted(gs, key=lambda g: member_count(g["id"], sid), reverse=True)
            title_sort = "ğŸ‘¥ ĞŸĞ¾ Ğ§Ğ»ĞµĞ½Ğ°Ğ¼"
        elif sort_by == "bank":
            gs = sorted(gs, key=lambda g: g.get("bank", 0), reverse=True)
            title_sort = "ğŸ’° ĞŸĞ¾ ĞšĞ°Ğ·Ğ½Ğµ"
        else:
            gs = sorted(gs, key=lambda g: calc_guild_power(g, sid), reverse=True)
            title_sort = "ğŸ’ª ĞŸĞ¾ ĞœĞ¾Ñ‰Ğ¸"
        
        desc = ""
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        for j, g in enumerate(gs[:10], 1):
            med = medals[j - 1] if j <= 3 else f"`#{j}`"
            cnt = member_count(g["id"], sid)
            pwr = calc_guild_power(g, sid)
            
            if sort_by == "power":
                stat = f"ğŸ’ª {pwr:,}"
            elif sort_by == "wins":
                stat = f"ğŸ† {g.get('wins', 0)} Ğ¿Ğ¾Ğ±ĞµĞ´"
            elif sort_by == "members":
                stat = f"ğŸ‘¥ {cnt} Ñ‡ĞµĞ»"
            else:
                stat = f"ğŸ’° {g.get('bank', 0):,}"
            
            desc += f"> {med} **[{g['tag']}] {g['name']}** â€” {stat}\n"
        
        embed = disnake.Embed(title=f"ğŸ… Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ {title_sort}", description=desc, color=0xFF69B4)
        await ctx.send(embed=embed)

    @commands.command(name="gtribute")
    @commands.cooldown(1, 3600, commands.BucketType.user)  # 1 Ñ€Ğ°Ğ· Ğ² Ñ‡Ğ°Ñ
    async def gtribute(self, ctx: commands.Context, amount: int):
        """ğŸ’ ĞŸĞ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´ĞµĞ½ĞµĞ³ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ğŸ’", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if amount <= 0:
            await ctx.send(embed=ce("ğŸ’", "> **âŒ Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0!**", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if coins < amount:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚", 
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{amount:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(u["guild_id"])
        new_coins = coins - amount
        new_bank = gd.get("bank", 0) + amount
        
        save_user(uid, sid, {"coins": new_coins})
        save_guild(gd["id"], {"bank": new_bank})
        
        desc = (
            f"> **[{gd['tag']}] {gd['name']}**\n"
            f"> _ _\n"
            f"> ğŸ’ **+{amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ!\n"
            f"> ğŸ’° ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ ĞºĞ°Ğ·Ğ½Ñ‹: **{new_bank:,}**\n"
            f"> _ _\n"
            f"> Ğ¢Ğ²Ğ¾Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        )
        
        await ctx.send(embed=ce("ğŸ’ ĞŸĞ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ", desc, ctx.guild, 0x00FF00))

    @commands.command(name="glevel")
    async def glevel(self, ctx: commands.Context, *, tag: str = None):
        """ğŸ“ˆ ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        
        if tag is None:
            u = get_user(uid, sid)
            if not u.get("guild_id"):
                await ctx.send(embed=ce("ğŸ“ˆ", "> **âŒ Ğ£ĞºĞ°Ğ¶Ğ¸ Ñ‚ĞµĞ³ Ğ¸Ğ»Ğ¸ ÑĞ¾ÑÑ‚Ğ¾Ğ¹ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000), delete_after=10)
                return
            gd = get_guild(u["guild_id"])
        else:
            gd = guild_by_tag(sid, tag)
        
        if not gd:
            await ctx.send(embed=ce("ğŸ“ˆ", f"> **âŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        level, xp, xp_needed = calc_guild_level(gd, sid)
        pwr = calc_guild_power(gd, sid)
        
        # ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑÑ-Ğ±Ğ°Ñ€ XP
        xp_bar = pbar(xp, xp_needed)
        
        # Ğ‘Ğ¾Ğ½ÑƒÑÑ‹ Ğ·Ğ° ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ
        level_bonus = {
            "members_bonus": level * 5,
            "bank_bonus_percent": level * 2,
            "power_bonus": level * 100
        }
        
        desc = (
            f"> ğŸ“› **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ:** [{gd['tag']}] {gd['name']}\n"
            f"> _ _\n"
            f"> ğŸ“Š **Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ:** {level}\n"
            f"> â­ **ĞĞ¿Ñ‹Ñ‚:** {xp:,}/{xp_needed:,}\n"
            f"> [{xp_bar}]\n"
            f"> _ _\n"
            f"> ğŸ’ª **ĞœĞ¾Ñ‰ÑŒ:** +{level_bonus['power_bonus']:,}\n"
            f"> ğŸ‘¥ **Ğ”Ğ¾Ğ¿. ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²:** +{level_bonus['members_bonus']}\n"
            f"> ğŸ’° **Ğ’Ğ¾Ğ·Ğ½Ğ°Ğ³Ñ€. ĞºĞ°Ğ·Ğ½Ñ‹:** +{level_bonus['bank_bonus_percent']}%\n"
            f"> _ _\n"
            f"> ğŸ¯ **ĞĞ±Ñ‰Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ:** {pwr:,}"
        )
        
        embed = disnake.Embed(title="ğŸ“ˆ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", description=desc, color=0x00D4FF)
        await ctx.send(embed=embed)

    @commands.command(name="glevels")
    async def glevels(self, ctx: commands.Context):
        """ğŸ¯ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹"""
        desc = (
            "> **ĞšĞ°Ğº Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸:**\n"
            "> âœ… ĞŸĞ¾Ğ±ĞµĞ¶Ğ´Ğ°Ñ‚ÑŒ Ğ² Ğ²Ğ¾Ğ¹Ğ½Ğ°Ñ…: +500 XP Ğ·Ğ° Ğ¿Ğ¾Ğ±ĞµĞ´Ñƒ\n"
            "> âœ… ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒ ĞºĞ°Ğ·Ğ½Ñƒ: +1 XP Ğ·Ğ° 100 Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            "> âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°Ñ‚ÑŒ ĞºĞ²ĞµÑÑ‚Ñ‹: +250 XP Ğ·Ğ° ĞºĞ²ĞµÑÑ‚\n"
            "> âœ… ĞŸĞ¾Ğ´Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹: +200 XP Ğ·Ğ° Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´\n"
            "> _ _\n"
            "> **Ğ‘Ğ¾Ğ½ÑƒÑÑ‹ Ğ¿Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½ÑĞ¼:**\n"
            "> ğŸ **Ğ—Ğ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ:**\n"
            ">   â€¢ +5 ÑĞ»Ğ¾Ñ‚Ğ¾Ğ² Ñ‡Ğ»ĞµĞ½Ğ¾Ğ²\n"
            ">   â€¢ +2% Ğº Ğ´Ğ¾Ñ…Ğ¾Ğ´Ñƒ ĞºĞ°Ğ·Ğ½Ñ‹\n"
            ">   â€¢ +100 Ğº Ğ¾Ğ±Ñ‰ĞµĞ¹ Ğ¼Ğ¾Ñ‰Ğ¸\n"
            "> _ _\n"
            "> ğŸ¯ **XP Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ñ:**\n"
            "> Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: 1000 + (ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ã— 500)\n"
            "> Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 1â†’2: 1500 XP\n"
            "> Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 10â†’11: 6000 XP\n"
            "> Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 20â†’21: 11000 XP"
        )
        
        embed = disnake.Embed(title="ğŸ¯ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ£Ñ€Ğ¾Ğ²Ğ½ĞµĞ¹ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹", description=desc, color=0x00D4FF)
        embed.set_footer(text="Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ !glevel [Ñ‚ĞµĞ³] Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑĞ°")
        await ctx.send(embed=embed)

    @commands.command(name="gtop")
    async def gtop(self, ctx: commands.Context):
        """ğŸ† Ğ¢ĞĞŸ 3 Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ ÑĞµÑ€Ğ²ĞµÑ€Ğ°"""
        sid = str(ctx.guild.id)
        try:
            gs = list(db["guilds"].find({"server_id": sid}))
            gs = sorted(gs, key=lambda g: calc_guild_power(g, sid), reverse=True)[:3]
        except Exception:
            gs = []
        
        if not gs:
            await ctx.send(embed=ce("ğŸ†", "> **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ½ĞµÑ‚!**", ctx.guild), delete_after=10)
            return
        
        desc = ""
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        for j, g in enumerate(gs):
            med = medals[j]
            cnt = member_count(g["id"], sid)
            pwr = calc_guild_power(g, sid)
            desc += (f"> {med} **[{g['tag']}] {g['name']}**\n"
                     f"> ğŸ’ª {pwr:,} | ğŸ‘¥ {cnt} Ñ‡ĞµĞ» | ğŸ‘‘ <@{g['owner_id']}>\n> _ _\n")
        
        embed = disnake.Embed(title="ğŸ† Ğ¢ĞĞŸ 3 Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ¡ĞµÑ€Ğ²ĞµÑ€Ğ°", description=desc, color=0xFFD700)
        await ctx.send(embed=embed)

    @commands.command(name="gcard", aliases=["gimage"])
    async def gcard(self, ctx: commands.Context, *, guild_tag: str = None):
        """ğŸƒ ĞšÑ€Ğ°ÑĞ¸Ğ²Ğ°Ñ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"""
        sid = str(ctx.guild.id)
        
        if guild_tag is None:
            # Ğ•ÑĞ»Ğ¸ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ½ĞµÑ‚, Ğ¸Ñ‰ĞµĞ¼ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ°
            user_data = find_user(ctx.author.id, sid)
            if not user_data or "guild_id" not in user_data or not user_data["guild_id"]:
                await ctx.send(embed=ce("âŒ", "> **Ğ’Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild), delete_after=10)
                return
            gd = db["guilds"].find_one({"id": user_data["guild_id"], "server_id": sid})
            if not gd:
                await ctx.send(embed=ce("âŒ", "> **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild), delete_after=10)
                return
        else:
            # Ğ˜Ñ‰ĞµĞ¼ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ¿Ğ¾ Ñ‚ĞµĞ³Ñƒ
            try:
                gd = db["guilds"].find_one({"tag": guild_tag.upper(), "server_id": sid})
            except Exception:
                gd = None
            
            if not gd:
                await ctx.send(embed=ce("âŒ", f"> **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ '{guild_tag}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild), delete_after=10)
                return
        
        try:
            # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸
            image_bytes = await create_guild_card(gd, sid, ctx.guild)
            
            # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ
            file = disnake.File(io.BytesIO(image_bytes), filename=f"guild_{gd['tag']}.png")
            embed = disnake.Embed(title=f"ğŸƒ {gd['tag']} - {gd['name']}", color=gd.get("color", 0xFF69B4))
            embed.set_image(url="attachment://guild_{}.png".format(gd['tag']))
            await ctx.send(file=file, embed=embed)
        except Exception as e:
            await ctx.send(embed=ce("âŒ", f"> **ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)[:50]}**", ctx.guild), delete_after=10)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ‘® ĞĞ”ĞœĞ˜ĞĞ¡ĞšĞ˜Ğ• ĞšĞĞœĞĞĞ”Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="greset")
    @is_admin()
    async def greset(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            us_list = list(db["users"].find({"server_id": sid}))
        except Exception:
            us_list = []
        for u in us_list:
            uid = uid_from_member_doc(u)
            if uid:
                save_user(uid, sid, {"messages": 0, "xp": 0, "level": 1, "coins": 0})
        await ctx.send(embed=ce("Admin", "ğŸ§¹ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ğ°.", ctx.guild))

    @commands.command(name="grebuildall")
    @is_admin()
    async def grebuildall(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            gs_list = list(db["guilds"].find({"server_id": sid}))
        except Exception:
            gs_list = []
        msg = await ctx.send(embed=ce("â³", f"> ĞŸĞµÑ€ĞµÑĞ¾Ğ·Ğ´Ğ°Ñ {len(gs_list)} Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹...", ctx.guild))
        for g in gs_list:
            gd    = dict(g)
            owner = ctx.guild.get_member(int(gd["owner_id"])) or ctx.author
            await rebuild(ctx.guild, gd, owner)
        await msg.edit(embed=ce("âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾!", f"> {len(gs_list)} Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ¿ĞµÑ€ĞµÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹!", ctx.guild))

    @commands.command(name="gforcecolor")
    @is_admin()
    async def gforcecolor(self, ctx: commands.Context, tag: str, color: str):
        sid = str(ctx.guild.id)
        gd  = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Admin", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        if color.lower() not in COLORS:
            await ctx.send(embed=ce("Admin", f"> **âŒ Ğ¦Ğ²ĞµÑ‚ `{color}` Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!**", ctx.guild, 0xFF0000))
            return
        gd["color"] = color.lower()
        save_guild(gd["id"], {"color": color.lower()})
        owner = ctx.guild.get_member(int(gd["owner_id"])) or ctx.author
        msg = await ctx.send(embed=ce("â³", f"> ĞœĞµĞ½ÑÑ Ñ†Ğ²ĞµÑ‚ **[{gd['tag']}]**...", ctx.guild))
        await rebuild(ctx.guild, gd, owner)
        await msg.edit(embed=ce("âœ…", f"> **[{gd['tag']}]** â†’ {COLORS[color.lower()]['label']}!",
                                 ctx.guild, COLORS[color.lower()]["hex"]))

    @commands.command(name="gforcedelete")
    @is_admin()
    async def gforcedelete(self, ctx: commands.Context, *, tag: str):
        sid = str(ctx.guild.id)
        gd  = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Admin", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        await self._dissolve_guild(ctx.guild, gd, sid)
        await ctx.send(embed=ce("âœ…", f"> **[{gd['tag']}] {gd['name']}** ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°.", ctx.guild))

    @commands.command(name="gforcekick")
    @is_admin()
    async def gforcekick(self, ctx: commands.Context, member: disnake.Member):
        uid, sid = str(member.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        if not u.get("guild_id"):
            await ctx.send(embed=ce("Admin", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        gid = u["guild_id"]
        gd  = get_guild(gid)
        if gd:
            officers = gd.get("officers", [])
            if uid in officers:
                officers.remove(uid)
                save_guild(gid, {"officers": officers})
        save_user(uid, sid, {"guild_id": None, "guild_rank": None})
        if gd:
            await refresh_access(ctx.guild, gd, member, remove=True)
        try:
            if member.display_name.startswith("["):
                clean = member.display_name.split("]", 1)[1].strip()
                await member.edit(nick=clean or None)
        except Exception:
            pass
        await ctx.send(embed=ce("ğŸ‘¢ Force Kick",
                                 f"> {member.mention} Ğ¿Ñ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¸ÑĞºĞ»ÑÑ‡Ñ‘Ğ½(Ğ°).", ctx.guild, 0xFF4444))

    @commands.command(name="gforcejoin")
    @is_admin()
    async def gforcejoin(self, ctx: commands.Context, member: disnake.Member, *, tag: str):
        uid, sid = str(member.id), str(ctx.guild.id)
        gd = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Admin", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        u = get_user(uid, sid)
        if u.get("guild_id"):
            await ctx.send(embed=ce("Admin", f"> **âŒ {member.display_name} ÑƒĞ¶Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        save_user(uid, sid, {"guild_id": gd["id"], "guild_rank": "member"})
        await refresh_access(ctx.guild, gd, member)
        try:
            old = member.display_name
            if old.startswith("[") and "]" in old:
                old = old.split("]", 1)[1].strip()
            await member.edit(nick=f"[{gd['tag']}] {old}"[:32])
        except Exception:
            pass
        await ctx.send(embed=ce("âœ… Force Join",
                                 f"> {member.mention} Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½(Ğ°) Ğ² **[{gd['tag']}]**.", ctx.guild))

    @commands.command(name="gsetowner")
    @is_admin()
    async def gsetowner(self, ctx: commands.Context, member: disnake.Member, *, tag: str):
        sid = str(ctx.guild.id)
        gd  = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Admin", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        uid = str(member.id)
        t   = get_user(uid, sid)
        if t.get("guild_id") != gd["id"]:
            await ctx.send(embed=ce("Admin", f"> **âŒ {member.display_name} Ğ½Ğµ Ğ² ÑÑ‚Ğ¾Ğ¹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**",
                                     ctx.guild, 0xFF0000))
            return
        old_owner = gd.get("owner_id")
        if old_owner:
            save_user(str(old_owner), sid, {"guild_rank": "member"})
        officers = gd.get("officers", [])
        if uid in officers:
            officers.remove(uid)
        save_guild(gd["id"], {"owner_id": uid, "officers": officers})
        save_user(uid, sid, {"guild_rank": "owner"})
        await ctx.send(embed=ce("ğŸ‘‘ ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ»Ğ¸Ğ´ĞµÑ€",
                                 f"> {member.mention} Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ»Ğ¸Ğ´ĞµÑ€ **[{gd['tag']}]**.", ctx.guild))

    @commands.command(name="gaddbank")
    @is_admin()
    async def gaddbank(self, ctx: commands.Context, tag: str, amount: int):
        sid = str(ctx.guild.id)
        gd = guild_by_tag(sid, tag)
        if not gd:
            await ctx.send(embed=ce("Admin", f"> **âŒ [{tag.upper()}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!**", ctx.guild, 0xFF0000))
            return
        try:
            db["guilds"].update_one({"id": gd["id"]}, {"$inc": {"bank": amount}})
            new_bank = (gd.get("bank", 0) or 0) + amount
            await ctx.send(embed=ce("ğŸ’° ĞšĞ°Ğ·Ğ½Ğ° Ğ¿Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°",
                                     f"> **[{gd['tag']}]** +{amount:,} Ğ¼Ğ¾Ğ½ĞµÑ‚\n> ĞšĞ°Ğ·Ğ½Ğ°: **{new_bank:,}**", ctx.guild))
        except Exception as e:
            await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°", f"> **âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ‘Ğ”: {e}**", ctx.guild, 0xFF0000))

    @commands.command(name="givemoney")
    @is_admin()
    async def givemoney(self, ctx: commands.Context, member: disnake.Member, amount: int):
        uid, sid = str(member.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        new_co = u.get("coins", 0) + amount
        save_user(uid, sid, {"coins": new_co})
        await ctx.send(embed=ce("ğŸ’° Ğ’Ñ‹Ğ´Ğ°Ñ‡Ğ°", f"> {member.mention} **+{amount:,}** | Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_co:,}**",
                                 ctx.guild))

    @commands.command(name="takemoney")
    @is_admin()
    async def takemoney(self, ctx: commands.Context, member: disnake.Member, amount: int):
        uid, sid = str(member.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        new_co = max(0, u.get("coins", 0) - amount)
        save_user(uid, sid, {"coins": new_co})
        await ctx.send(embed=ce("Admin", f"> Ğ˜Ğ·ÑŠÑÑ‚Ğ¾ **{amount:,}** Ñƒ {member.mention}\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_co:,}**",
                                 ctx.guild))

    @commands.command(name="resetuser")
    @is_admin()
    async def resetuser(self, ctx: commands.Context, member: disnake.Member):
        db["users"].delete_one({"user_id": str(member.id), "server_id": str(ctx.guild.id)})
        await ctx.send(embed=ce("Admin", f"> Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ {member.mention} ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ñ‹.", ctx.guild))

    @commands.command(name="glistall")
    @is_admin()
    async def glistall(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            gs = list(db["guilds"].find({"server_id": sid}))
        except Exception:
            gs = []
        if not gs:
            await ctx.send("> Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ½ĞµÑ‚.")
            return
        desc = "".join(f"> **[{g['tag']}] {g['name']}** (ID:{g['id']})\n" for g in gs)
        await ctx.send(embed=ce("Ğ’ÑĞµ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", desc, ctx.guild))

    @commands.command(name="setmessages")
    @is_admin()
    async def setmessages(self, ctx: commands.Context, member: disnake.Member, amount: int):
        save_user(str(member.id), str(ctx.guild.id), {"messages": amount})
        await ctx.send(embed=ce("ğŸ“", f"> {member.mention}: **{amount:,}** ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹", ctx.guild))

    @commands.command(name="setxp")
    @is_admin()
    async def setxp(self, ctx: commands.Context, member: disnake.Member, amount: int):
        lvl = calc_level(amount)
        save_user(str(member.id), str(ctx.guild.id), {"xp": amount, "level": lvl})
        await ctx.send(embed=ce("â­ XP", f"> {member.mention}: **{amount:,}** XP | ÑƒÑ€. **{lvl}**", ctx.guild))

    @commands.command(name="gcleardata")
    @is_admin()
    async def gcleardata(self, ctx: commands.Context, member: disnake.Member):
        db["users"].delete_one({"user_id": str(member.id), "server_id": str(ctx.guild.id)})
        await ctx.send(embed=ce("ğŸ—‘ï¸ Ğ¡Ğ±Ñ€Ğ¾Ñ", f"> Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ {member.mention} ÑĞ±Ñ€Ğ¾ÑˆĞµĞ½Ñ‹.", ctx.guild, 0xFF4444))

    @commands.command(name="stats")
    @is_admin()
    async def stats(self, ctx: commands.Context):
        sid = str(ctx.guild.id)
        try:
            gs_list = list(db["guilds"].find({"server_id": sid}))
            us_list = list(db["users"].find({"server_id": sid}))
        except Exception:
            gs_list, us_list = [], []
        await ctx.send(embed=ce("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°",
                                 f"> ğŸ° Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹: **{len(gs_list)}**\n"
                                 f"> ğŸ‘¤ Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²: **{len(us_list)}**\n"
                                 f"> ğŸ’° ĞœĞ¾Ğ½ĞµÑ‚: **{sum(u.get('coins',0) for u in us_list):,}**\n"
                                 f"> â­ XP: **{sum(u.get('xp',0) for u in us_list):,}**\n"
                                 f"> ğŸ’¬ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹: **{sum(u.get('messages',0) for u in us_list):,}**",
                                 ctx.guild))

    @commands.command(name="gsetcalendar")
    @is_admin()
    async def gsetcalendar(self, ctx: commands.Context, channel: disnake.TextChannel):
        save_settings(str(ctx.guild.id), {SEASON_CH_KEY: channel.id})
        await ctx.send(embed=ce("âœ…", f"> ĞĞ½Ğ¾Ğ½ÑÑ‹ â†’ {channel.mention}", ctx.guild))

    @commands.command(name="gsetmsg")
    @is_admin()
    async def gsetmsg(self, ctx: commands.Context, amount: int):
        save_settings(str(ctx.guild.id), {"msg_required": amount})
        await ctx.send(embed=ce("âš™ï¸", f"> ĞŸĞ¾Ñ€Ğ¾Ğ³ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸: **{amount}** ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹", ctx.guild))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŒ¸â„ï¸ Ğ˜Ğ’Ğ•ĞĞ¢
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def _season(self) -> str:
        return "winter" if datetime.utcnow().month in [12, 1, 2] else "spring"

    def _stasks(self, s: str) -> list:
        return WINTER_TASKS if s == "winter" else SPRING_TASKS

    def _stitle(self, s: str) -> str:
        return "â„ï¸ ĞšĞ¾Ğ½ĞµÑ† Ğ—Ğ¸Ğ¼Ñ‹" if s == "winter" else "ğŸŒ¸ ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ’ĞµÑĞ½Ñ‹"

    @commands.command(name="gseason")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def gseason(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        s     = self._season()
        tasks = self._stasks(s)
        u = get_user(uid, sid)
        pr = u.get("event_progress", {})
        cl = u.get("event_claimed", [])
        desc = f"> **Ğ¡ĞµĞ·Ğ¾Ğ½: {self._stitle(s)}**\n> _ _\n"
        for t in tasks:
            cur  = pr.get(t["id"], 0)
            bar  = pbar(cur, t["goal"])
            if t["id"] in cl:
                status = "âœ… ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾"
            elif cur >= t["goal"]:
                status = "ğŸŸ© Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! ĞĞ°Ğ¶Ğ¼Ğ¸ â†“"
            else:
                status = f"â³ {cur}/{t['goal']}"
            desc += (f"> {t['emoji']} **{t['name']}** â€” {status}\n"
                     f"> _{t['desc']}_\n> [{bar}] ğŸ’° {t['reward']:,}\n> _ _\n")
        col = 0x5BC8FF if s == "winter" else 0xFF69B4
        await ctx.send(embed=ce(f"ğŸ‰ Ğ˜Ğ²ĞµĞ½Ñ‚ | {self._stitle(s)}", desc, ctx.guild, col),
                       components=[season_claim_row(ctx.author.id, s)])

    async def _prog(self, uid: str, sid: str, task_id: str, n: int = 1):
        u  = get_user(uid, sid)
        pr = u.get("event_progress", {})
        tl = self._stasks(self._season())
        t  = next((x for x in tl if x["id"] == task_id), None)
        if t:
            pr[task_id] = min(pr.get(task_id, 0) + n, t["goal"])
            save_user(uid, sid, {"event_progress": pr})

    @commands.command(name="snowball")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def snowball(self, ctx: commands.Context, target: disnake.Member = None):
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "wt_snow")
        t = f"Ğ² {target.mention}" if target else "Ğ² Ğ²Ğ¾Ğ·Ğ´ÑƒÑ…"
        await ctx.send(embed=ce("â„ï¸ Ğ¡Ğ½ĞµĞ¶Ğ¾Ğº!", f"> {ctx.author.mention} ĞºĞ¸Ğ½ÑƒĞ» ÑĞ½ĞµĞ¶Ğ¾Ğº {t}! â„ï¸",
                                 ctx.guild, 0x5BC8FF))

    @commands.command(name="warm")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def warm(self, ctx: commands.Context, member: disnake.Member):
        if member.id == ctx.author.id:
            await ctx.send(embed=ce("Ğ¢ĞµĞ¿Ğ»Ğ¾", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ ÑĞµĞ±Ğµ!**", ctx.guild, 0xFF0000))
            return
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "wt_warm")
        await ctx.send(embed=ce("ğŸ”¥ Ğ¢ĞµĞ¿Ğ»Ğ¾!", f"> {ctx.author.mention} Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ğ»ÑÑ Ñ‚ĞµĞ¿Ğ»Ğ¾Ğ¼ Ñ {member.mention}! ğŸ§£",
                                 ctx.guild, 0xFF8C00))

    @commands.command(name="snowman")
    @commands.cooldown(*COOLDOWNS["super_heavy"], commands.BucketType.user)
    async def snowman(self, ctx: commands.Context):
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "wt_man")
        await ctx.send(embed=ce("â›„ Ğ¡Ğ½ĞµĞ³Ğ¾Ğ²Ğ¸Ğº!", f"> {ctx.author.mention} ÑĞ»ĞµĞ¿Ğ¸Ğ» ÑĞ½ĞµĞ³Ğ¾Ğ²Ğ¸ĞºĞ°! â›„ğŸ¥•",
                                 ctx.guild, 0x5BC8FF))

    @commands.command(name="gpatrol")
    @commands.cooldown(*COOLDOWNS["wars"], commands.BucketType.user)
    async def gpatrol(self, ctx: commands.Context):
        u = get_user(str(ctx.author.id), str(ctx.guild.id))
        if not u.get("guild_id"):
            await ctx.send(embed=ce("ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒ", "> **âŒ Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!**", ctx.guild, 0xFF0000))
            return
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "wt_patrol")
        msg = random.choice(["ğŸ›¡ï¸ Ğ’Ñ€Ğ°Ğ³Ğ¸ Ñ€Ğ°Ğ·Ğ±ĞµĞ¶Ğ°Ğ»Ğ¸ÑÑŒ!", "â„ï¸ ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒ Ğ¿Ñ€Ğ¾ÑˆÑ‘Ğ»!", "âš”ï¸ Ğ“Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ğ¿Ğ¾Ğ´ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¾Ğ¹!"])
        await ctx.send(embed=ce("ğŸ›¡ï¸ ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒ!", f"> {msg}", ctx.guild, 0x4A90D9))

    @commands.command(name="flower")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def flower(self, ctx: commands.Context):
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "sp_flower")
        f = random.choice(["ğŸŒ¸ Ğ¡Ğ°ĞºÑƒÑ€Ğ°", "ğŸŒ· Ğ¢ÑĞ»ÑŒĞ¿Ğ°Ğ½", "ğŸŒº Ğ“Ğ¸Ğ±Ğ¸ÑĞºÑƒÑ", "ğŸŒ» ĞŸĞ¾Ğ´ÑĞ¾Ğ»Ğ½ÑƒÑ…", "ğŸŒ¼ Ğ Ğ¾Ğ¼Ğ°ÑˆĞºĞ°"])
        await ctx.send(embed=ce("ğŸŒ¸ Ğ¡Ğ±Ğ¾Ñ€!", f"> {ctx.author.mention} Ğ½Ğ°ÑˆÑ‘Ğ» **{f}**!", ctx.guild, 0xFF69B4))

    @commands.command(name="plant")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def plant(self, ctx: commands.Context, member: disnake.Member):
        if member.id == ctx.author.id:
            await ctx.send(embed=ce("ĞŸĞ¾ÑĞ°Ğ´ĞºĞ°", "> **âŒ ĞĞµĞ»ÑŒĞ·Ñ ÑĞµĞ±Ğµ!**", ctx.guild, 0xFF0000))
            return
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "sp_plant")
        await ctx.send(embed=ce("ğŸŒ± ĞŸĞ¾ÑĞ°Ğ´ĞºĞ°!", f"> {ctx.author.mention} Ğ¿Ğ¾ÑĞ°Ğ´Ğ¸Ğ» Ñ†Ğ²ĞµÑ‚Ğ¾Ğº Ğ´Ğ»Ñ {member.mention}! ğŸŒ·",
                                 ctx.guild, 0x2ECC71))

    @commands.command(name="spring_rain")
    @commands.cooldown(*COOLDOWNS["super_heavy"], commands.BucketType.user)
    async def spring_rain(self, ctx: commands.Context):
        await self._prog(str(ctx.author.id), str(ctx.guild.id), "sp_rain")
        await ctx.send(embed=ce("ğŸŒ§ï¸ Ğ’ĞµÑĞµĞ½Ğ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ¶Ğ´ÑŒ!",
                                 f"> {ctx.author.mention} Ğ¿Ñ€Ğ¸Ğ·Ğ²Ğ°Ğ» Ğ²ĞµÑĞµĞ½Ğ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ¶Ğ´ÑŒ! ğŸŒ§ï¸ğŸŒ¸",
                                 ctx.guild, 0xFF69B4))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŒ¾ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ¤Ğ•Ğ Ğœ (ĞŸĞĞ¡Ğ¡Ğ˜Ğ’ĞĞ«Ğ™ Ğ”ĞĞ¥ĞĞ”)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="buyfarm", aliases=["farm"])
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def buyfarm(self, ctx: commands.Context, farm_name: str = None):
        """ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ°"""
        if not INCOME_SOURCES:
            await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°", "> **âŒ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ„ĞµÑ€Ğ¼ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°**", ctx.guild, 0xFF0000))
            return
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        lvl = u.get("level", 1)
        
        if not farm_name:
            # ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ñ‚Ğ°Ğ»Ğ¾Ğ³ Ñ„ĞµÑ€Ğ¼
            desc = ""
            for tier_num in range(1, 6):
                tier_farms = get_income_sources_by_tier(tier_num)
                if tier_farms:
                    tier_info = INCOME_TIERS.get(tier_num, {})
                    desc += f"\n> **{tier_info.get('emoji')} Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ {tier_num} â€” {tier_info.get('name')}:**\n"
                    for farm_key, farm in tier_farms.items():
                        can_afford = u.get("coins", 0) >= farm["price"]
                        can_unlock = lvl >= farm.get("unlock_level", 1)
                        status = "âœ…" if can_afford and can_unlock else ("ğŸ”’" if not can_unlock else "âŒ")
                        desc += f"> {status} `{farm_key}` â€” {farm['name']} ({farm['price']:,} Ğ¼Ğ¾Ğ½ĞµÑ‚)\n"
                        desc += f">    +{farm['income_per_hour']:,}/Ñ‡ â€” Ğ¾ĞºÑƒĞ¿. {calculate_farm_payback_days(farm_key):.1f} Ğ´Ğ½Ñ\n"
            
            await ctx.send(embed=ce("ğŸŒ¾ ĞšĞ°Ñ‚Ğ°Ğ»Ğ¾Ğ³ Ñ„ĞµÑ€Ğ¼",
                                    desc + f"\n> _ _\n> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: `!buyfarm <Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ>`",
                                    ctx.guild))
            return
        
        farm_key = farm_name.lower()
        if farm_key not in INCOME_SOURCES:
            await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°", f"> **âŒ Ğ¤ĞµÑ€Ğ¼Ğ° '{farm_name}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°**", ctx.guild, 0xFF0000))
            return
        
        farm = INCOME_SOURCES[farm_key]
        if u.get("coins", 0) < farm["price"]:
            need = farm["price"] - u.get("coins", 0)
            await ctx.send(embed=ce("ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° Ñ„ĞµÑ€Ğ¼",
                                    f"> **âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ {need:,} Ğ¼Ğ¾Ğ½ĞµÑ‚!**\n> Ğ¢Ğ²Ğ¾Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: {u.get('coins', 0):,}",
                                    ctx.guild, 0xFF0000))
            return
        
        if lvl < farm.get("unlock_level", 1):
            await ctx.send(embed=ce("ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° Ñ„ĞµÑ€Ğ¼",
                                    f"> **âŒ ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡ĞµĞ½ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ!**\n> Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ ÑƒÑ€. {farm.get('unlock_level', 1)}, Ñƒ Ñ‚ĞµĞ±Ñ {lvl}",
                                    ctx.guild, 0xFF0000))
            return
        
        farms = u.get("farms", [])
        if farm_key in farms:
            await ctx.send(embed=ce("ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° Ñ„ĞµÑ€Ğ¼",
                                    f"> **âš ï¸ Ğ£ Ñ‚ĞµĞ±Ñ ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ ÑÑ‚Ğ° Ñ„ĞµÑ€Ğ¼Ğ°!**",
                                    ctx.guild, 0xFF8800))
            return
        
        # ĞŸĞ¾ĞºÑƒĞ¿Ğ°ĞµĞ¼ Ñ„ĞµÑ€Ğ¼Ñƒ
        farms.append(farm_key)
        new_coins = u.get("coins", 0) - farm["price"]
        save_user(uid, sid, {"coins": new_coins, "farms": farms})
        
        await ctx.send(embed=ce("ğŸŒ¾ Ğ¤ĞµÑ€Ğ¼Ğ° ĞºÑƒĞ¿Ğ»ĞµĞ½Ğ°!",
                                f"> {farm['emoji']} **{farm['name']}**\n> _ _\n"
                                f"> ğŸ’° **-{farm['price']:,} Ğ¼Ğ¾Ğ½ĞµÑ‚**\n"
                                f"> ğŸ“ˆ **+{farm['income_per_hour']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ Ğ² Ñ‡Ğ°Ñ\n> _ _\n"
                                f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**",
                                ctx.guild, farm['tier'] * 0x101010))

    @commands.command(name="myfarms")
    @commands.cooldown(*COOLDOWNS["info_light"], commands.BucketType.user)
    async def myfarms(self, ctx: commands.Context, member: disnake.Member = None):
        """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ‚Ğ²Ğ¾Ğ¸ Ñ„ĞµÑ€Ğ¼Ñ‹ Ğ¸ Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ¾Ñ…Ğ¾Ğ´"""
        if not INCOME_SOURCES:
            await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°", "> **âŒ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ„ĞµÑ€Ğ¼ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°**", ctx.guild, 0xFF0000))
            return
        
        target = member or ctx.author
        uid, sid = str(target.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        farms = u.get("farms", [])
        
        if not farms:
            await ctx.send(embed=ce("ğŸŒ¾ Ğ¢Ğ²Ğ¾Ğ¸ Ñ„ĞµÑ€Ğ¼Ñ‹",
                                    f"> **{target.display_name}** ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ñ„ĞµÑ€Ğ¼\n> ĞĞ°Ñ‡Ğ½Ğ¸ Ñ `!buyfarm`",
                                    ctx.guild, 0xFF8800))
            return
        
        total_income = get_income_per_hour(farms, get_guild(u.get("guild_id")).get("upgrades", []) if u.get("guild_id") else [])
        
        desc = f"> **Ğ’ÑĞµĞ³Ğ¾ Ñ„ĞµÑ€Ğ¼:** {len(farms)}\n> **Ğ”Ğ¾Ñ…Ğ¾Ğ´ Ğ² Ñ‡Ğ°Ñ:** {total_income:,} Ğ¼Ğ¾Ğ½ĞµÑ‚\n> **Ğ”Ğ¾Ñ…Ğ¾Ğ´ Ğ² Ğ´ĞµĞ½ÑŒ:** {total_income * 24:,} Ğ¼Ğ¾Ğ½ĞµÑ‚\n> _ _\n"
        
        for tier_num in range(1, 6):
            tier_farms = [f for f in farms if INCOME_SOURCES.get(f, {}).get("tier") == tier_num]
            if tier_farms:
                tier_info = INCOME_TIERS.get(tier_num, {})
                desc += f"> **{tier_info.get('emoji')} {tier_info.get('name')} ({len(tier_farms)}):**\n"
                for farm_key in tier_farms:
                    farm = INCOME_SOURCES[farm_key]
                    desc += f"> {farm['emoji']} **{farm['name']}** â€” +{farm['income_per_hour']:,}/Ñ‡\n"
                desc += "> _ _\n"
        
        e = ce("ğŸŒ¾ Ğ¢Ğ²Ğ¾Ğ¸ Ñ„ĞµÑ€Ğ¼Ñ‹", desc, ctx.guild, 0x2ECC71)
        if ctx.author == target:
            e.add_field(name="Ğ¡Ğ¾Ğ²ĞµÑ‚", value="Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!harvest` ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ‡Ğ°Ñ Ğ´Ğ»Ñ ÑĞ±Ğ¾Ñ€Ğ° Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ°", inline=False)
        await ctx.send(embed=e)

    @commands.command(name="harvest")
    @commands.cooldown(*COOLDOWNS["eco_medium"], commands.BucketType.user)
    async def harvest(self, ctx: commands.Context):
        """Ğ¡Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ´Ğ¾Ñ…Ğ¾Ğ´ Ğ¾Ñ‚ Ñ„ĞµÑ€Ğ¼Ñ‹ (Ñ€Ğ°Ğ· Ğ² Ñ‡Ğ°Ñ)"""
        if not INCOME_SOURCES:
            await ctx.send(embed=ce("ĞÑˆĞ¸Ğ±ĞºĞ°", "> **âŒ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ„ĞµÑ€Ğ¼ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°**", ctx.guild, 0xFF0000))
            return
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        farms = u.get("farms", [])
        
        if not farms:
            await ctx.send(embed=ce("ğŸŒ¾ ĞŸÑ€Ğ¸ ÑĞ±Ğ¾Ñ€Ğµ ÑƒÑ€Ğ¾Ğ¶Ğ°Ñ",
                                    "> **âŒ Ğ£ Ñ‚ĞµĞ±Ñ Ğ½ĞµÑ‚ Ñ„ĞµÑ€Ğ¼!**\n> ĞšÑƒĞ¿Ğ¸ Ñ„ĞµÑ€Ğ¼Ñƒ Ñ‡ĞµÑ€ĞµĞ· `!buyfarm`",
                                    ctx.guild, 0xFF0000))
            return
        
        now = datetime.utcnow()
        last_harvest = u.get("last_farm_income")
        
        if last_harvest:
            try:
                last_time = datetime.fromisoformat(last_harvest)
                diff = now - last_time
                if diff.total_seconds() < 3600:  # ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ Ñ‡Ğ°Ñ
                    rem = 3600 - diff.total_seconds()
                    m = int(rem // 60)
                    await ctx.send(embed=ce("ğŸŒ¾ ĞŸÑ€Ğ¸ ÑĞ±Ğ¾Ñ€Ğµ ÑƒÑ€Ğ¾Ğ¶Ğ°Ñ",
                                           f"> â° Ğ£Ğ¶Ğµ ÑĞ¾Ğ±Ğ¸Ñ€Ğ°Ğ» ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ!\n> Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹ÑÑ Ñ‡ĞµÑ€ĞµĞ· **{m} Ğ¼Ğ¸Ğ½ÑƒÑ‚**",
                                           ctx.guild, 0xFF8800))
                    return
            except Exception:
                pass
        
        # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ´Ğ¾Ñ…Ğ¾Ğ´
        gd = get_guild(u.get("guild_id"))
        guild_upgrades = gd.get("upgrades", []) if gd else []
        income = get_income_per_hour(farms, guild_upgrades)
        
        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ±Ğ¾Ğ½ÑƒÑÑ‹ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ·Ğ° Ğ²Ğ·Ğ½Ğ¾Ñ
        vault_bonus = get_guild_vault_bonus(guild_upgrades) if gd else 1.0
        
        # Ğ§Ğ°ÑÑ‚ÑŒ Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ° Ğ¸Ğ´Ñ‘Ñ‚ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
        guild_contribution = int(income * (vault_bonus - 1.0) * 0.1) if gd else 0
        player_income = income - guild_contribution
        
        new_coins = u.get("coins", 0) + player_income
        save_user(uid, sid, {
            "coins": new_coins,
            "last_farm_income": now.isoformat(),
            "farm_income_collected": u.get("farm_income_collected", 0) + player_income
        })
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
        if gd and guild_contribution > 0:
            save_guild(gd["id"], {"bank": gd.get("bank", 0) + guild_contribution})
        
        desc = f"> {ctx.author.mention} ÑĞ¾Ğ±Ñ€Ğ°Ğ» ÑƒÑ€Ğ¾Ğ¶Ğ°Ğ¹!\n> _ _\n"
        desc += f"> ğŸ’° **+{player_income:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ (Ğ·Ğ° Ñ‡Ğ°Ñ)\n"
        if guild_contribution > 0:
            desc += f"> ğŸ° **+{guild_contribution:,}** Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ ({vault_bonus*100-100:.0f}%)\n"
        desc += f"> _ _\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("ğŸŒ¾ Ğ¡Ğ±Ğ¾Ñ€ ÑƒÑ€Ğ¾Ğ¶Ğ°Ñ!", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ… Ğ¤ĞĞĞĞ’ĞĞ¯ Ğ—ĞĞ”ĞĞ§Ğ ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ˜ Ğ‘ĞĞ¤Ğ¤ĞĞ’
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @tasks.loop(minutes=30)
    async def verify_member_badges_task(self):
        """
        Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ğ°Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ĞµĞ¹ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€Ğ°.
        ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ ĞºÑÑˆ Ğ±Ğ°Ñ„Ñ„Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾ĞµĞ½Ğ¸Ñ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğº Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ°Ğ¼.
        Ğ˜ Ğ¿Ñ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°ĞµÑ‚ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ñ€Ğ¾Ğ»Ğ¸ Ğ½Ğ° Discord.
        """
        global _member_badge_cache
        try:
            home_server = self.bot.get_guild(HOME_SERVER_ID)
            if not home_server:
                return
            
            # ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ²ÑˆĞ¸Ğ¹ ĞºÑÑˆ
            now = datetime.utcnow().timestamp()
            expired_keys = [
                k for k, v in _member_badge_cache.items()
                if (now - v[2]) > _cache_ttl
            ]
            for k in expired_keys:
                del _member_badge_cache[k]
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
            checked = 0
            roles_updated = 0
            for member in home_server.members[:50]:  # 50 ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ·Ğ° Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ
                if member.bot:
                    continue
                
                badge_level = await check_member_profile(member)
                _member_badge_cache[member.id] = (badge_level, 
                    MEMBER_BADGES.get(badge_level, {}).get("multiplier", 1.0),
                    now)
                
                # ĞŸÑ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ¾Ğ»Ğ¸ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ±Ğ°Ñ„Ñ„Ğ°
                try:
                    for badge_key, badge_data in MEMBER_BADGES.items():
                        role_id = badge_data.get("role_id")
                        if not role_id:
                            continue
                        role = home_server.get_role(role_id)
                        if not role:
                            continue
                        
                        if badge_level == badge_key:
                            # ĞÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ€Ğ¾Ğ»ÑŒ
                            if role not in member.roles:
                                await member.add_roles(role, reason="ĞĞ²Ñ‚Ğ¾Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ±Ğ°Ñ„Ñ„Ğ°")
                                roles_updated += 1
                        else:
                            # ĞÑƒĞ¶Ğ½Ğ¾ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ€Ğ¾Ğ»ÑŒ
                            if role in member.roles:
                                await member.remove_roles(role, reason="ĞĞ²Ñ‚Ğ¾Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ±Ğ°Ñ„Ñ„Ğ°")
                                roles_updated += 1
                except Exception as e:
                    print(f"[verify_member_badges_task] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ Ñ Ñ€Ğ¾Ğ»ÑĞ¼Ğ¸ {member.id}: {e}")
                
                checked += 1
                await asyncio.sleep(0.2)  # ĞĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ°Ñ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ´Ğ»Ñ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ñ rate limit
            
            if checked > 0 or roles_updated > 0:
                print(f"[verify_member_badges_task] ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾ {checked} ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ², Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ {roles_updated} Ñ€Ğ¾Ğ»ĞµĞ¹")
                
        except Exception as e:
            print(f"[verify_member_badges_task] ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")

    @tasks.loop(hours=1)
    async def season_task(self):
        season = self._season()
        for srv in self.bot.guilds:
            sid = str(srv.id)
            st  = get_settings(sid)
            if st.get("last_season") == season:
                continue
            ch_id = st.get(SEASON_CH_KEY)
            if not ch_id:
                continue
            ch = srv.get_channel(int(ch_id))
            if not ch:
                continue
            if season == "winter":
                title = "â„ï¸ ĞšĞĞĞ•Ğ¦ Ğ—Ğ˜ĞœĞ« â€” Ğ˜Ğ²ĞµĞ½Ñ‚ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑÑ!"
                col   = 0x5BC8FF
                desc  = ("> â„ï¸ `!snowball` Â· ğŸ”¥ `!warm @` Â· â›„ `!snowman` Â· ğŸ›¡ï¸ `!gpatrol`\n"
                         "> _ _\n> `!gseason` â€” Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ ğŸ")
            else:
                title = "ğŸŒ¸ ĞĞĞ§ĞĞ›Ğ Ğ’Ğ•Ğ¡ĞĞ« â€” Ğ˜Ğ²ĞµĞ½Ñ‚ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑÑ!"
                col   = 0xFF69B4
                desc  = ("> ğŸŒ¸ `!flower` Â· ğŸŒ± `!plant @` Â· ğŸŒ§ï¸ `!spring_rain`\n"
                         "> _ _\n> `!gseason` â€” Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ ğŸ")
            try:
                await ch.send(embed=ce(title, desc, srv, col))
                save_settings(sid, {"last_season": season})
            except Exception as ex:
                print(f"[SEASON] {srv.name}: {ex}")

    @season_task.before_loop
    async def before_season(self):
        await self.bot.wait_until_ready()

    # â”€â”€ Ğ‘Ğ°Ñ„Ñ„Ñ‹ Ğ¸ Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @commands.command(name="mybadge")
    async def mybadge(self, ctx: commands.Context, user: Optional[disnake.Member] = None):
        """ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ°Ñ„Ñ„Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°."""
        target = user or ctx.author
        home_server = self.bot.get_guild(HOME_SERVER_ID)
        if not home_server:
            await ctx.send("âŒ Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²ĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", delete_after=10)
            return
        
        member = home_server.get_member(target.id)
        if not member:
            await ctx.send("âŒ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ½Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ¼ ÑĞµÑ€Ğ²ĞµÑ€Ğµ", delete_after=10)
            return
        
        badge_level = await check_member_profile(member)
        badge_info = MEMBER_BADGES.get(badge_level, {})
        multiplier = badge_info.get("multiplier", 1.0)
        description = badge_info.get("description", "Ğ‘ĞµĞ· Ğ±Ğ°Ñ„Ñ„Ğ°")
        emoji = badge_info.get("emoji", "âŒ")
        
        desc = f"{emoji} **{description}**\n> ĞœÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€: **x{multiplier}**"
        
        if badge_level:
            desc += f"\n> Ğ¢Ğ°Ğ³: {'ğŸ·ï¸' if '[' in (member.display_name or '') else 'âŒ'}"
            desc += f"\n> Ğ¡ÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° ÑĞµÑ€Ğ²ĞµÑ€: {'âœ…' if 'discord.gg' in (member.bio or '').lower() else 'âŒ'}"
        
        await ctx.send(embed=ce("ğŸ… Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ°Ñ„Ñ„Ğ°", desc, ctx.guild))

    @commands.command(name="badgestatus")
    @commands.has_permissions(administrator=True)
    async def badgestatus(self, ctx: commands.Context, user: disnake.Member):
        """[ĞĞ´Ğ¼Ğ¸Ğ½] ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ°Ñ„Ñ„Ğ° ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ° Ğ¸ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ."""
        home_server = self.bot.get_guild(HOME_SERVER_ID)
        if not home_server:
            await ctx.send("âŒ Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²ĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", delete_after=10)
            return
        
        member = home_server.get_member(user.id)
        if not member:
            await ctx.send("âŒ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ½Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ¼ ÑĞµÑ€Ğ²ĞµÑ€Ğµ", delete_after=10)
            return
        
        badge_level = await check_member_profile(member)
        badge_info = MEMBER_BADGES.get(badge_level, {})
        
        desc = f"ğŸ‘¤ {member.mention}\n> _ _\n"
        desc += f"**ĞĞ¸Ğº:** {member.display_name}\n"
        desc += f"**Bio:** {member.bio or 'ĞĞµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾'}\n"
        desc += f"> _ _\n"
        desc += f"**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ°Ñ„Ñ„Ğ°:** {badge_info.get('emoji', 'âŒ')} {badge_info.get('description', 'Ğ‘ĞµĞ· Ğ±Ğ°Ñ„Ñ„Ğ°')}\n"
        desc += f"**ĞœÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€:** x{badge_info.get('multiplier', 1.0)}\n"
        
        if badge_info.get('role_id'):
            role = home_server.get_role(badge_info['role_id'])
            if role:
                desc += f"**Ğ Ğ¾Ğ»ÑŒ:** {role.mention}"
        
        await ctx.send(embed=ce("ğŸ… Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ±Ğ°Ñ„Ñ„Ğ°", desc, ctx.guild))

    @commands.command(name="verifyall")
    @commands.is_owner()
    async def verifyall(self, ctx: commands.Context):
        """[Ğ’Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ†] ĞŸÑ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€Ğ°."""
        global _member_badge_cache
        home_server = self.bot.get_guild(HOME_SERVER_ID)
        if not home_server:
            await ctx.send("âŒ Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²ĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", delete_after=10)
            return
        
        msg = await ctx.send("â³ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²...")
        checked = 0
        now = datetime.utcnow().timestamp()
        
        for member in home_server.members:
            if member.bot:
                continue
            
            badge_level = await check_member_profile(member)
            _member_badge_cache[member.id] = (badge_level,
                MEMBER_BADGES.get(badge_level, {}).get("multiplier", 1.0),
                now)
            checked += 1
        
        await msg.edit(content=f"âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾ **{checked}** ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² | ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ ĞºÑÑˆ Ğ±Ğ°Ñ„Ñ„Ğ¾Ğ²")

    @commands.command(name="applyretro")
    @commands.is_owner()
    async def applyretro(self, ctx: commands.Context):
        """
        [Ğ’Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ†] Ğ ĞµÑ‚Ñ€Ğ¾Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€Ğ¾Ğ»Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ñ‡Ğ»ĞµĞ½Ğ¾Ğ².
        Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ñ€Ğ¾Ğ»Ğ¸ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹, Ñƒ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ¸Ñ… ĞµÑ‰Ñ‘ Ğ½ĞµÑ‚.
        """
        msg = await ctx.send("â³ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğº ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¼ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸ÑĞ¼...")
        sid = str(ctx.guild.id)
        
        try:
            guilds_data = list(db["guilds"].find({"server_id": sid}))
        except Exception as e:
            await msg.edit(content=f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹: {e}")
            return
        
        created_roles = 0
        applied_members = 0
        
        for gd in guilds_data:
            gid = gd.get("id")
            if not gid:
                continue
            
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ€Ğ¾Ğ»Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
            guild_role_id = gd.get("guild_role_id")
            guild_role = None
            
            if guild_role_id:
                guild_role = ctx.guild.get_role(guild_role_id)
            
            # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ñ€Ğ¾Ğ»ÑŒ ĞµÑĞ»Ğ¸ ĞµÑ‘ Ğ½ĞµÑ‚
            if not guild_role:
                try:
                    guild_color = COLORS.get(gd.get("color", DEFAULT_COLOR), {}).get("hex", 0x3498DB)
                    guild_role = await ctx.guild.create_role(
                        name=f"[{gd['tag']}] Ğ§Ğ»ĞµĞ½Ñ‹",
                        color=disnake.Color(guild_color),
                        reason="Ğ ĞµÑ‚Ñ€Ğ¾Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ¾Ğ»Ğ¸ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"
                    )
                    save_guild(gid, {"guild_role_id": guild_role.id})
                    created_roles += 1
                except Exception as e:
                    print(f"[applyretro] ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ»Ñ {gd['tag']}: {e}")
                    continue
            
            # ĞŸÑ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ¾Ğ»ÑŒ Ğ²ÑĞµĞ¼ Ñ‡Ğ»ĞµĞ½Ğ°Ğ¼ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸
            try:
                members = guild_members(gid, sid)
                for member_data in members:
                    mid = member_data.get("user_id")
                    if not mid:
                        continue
                    
                    try:
                        member = ctx.guild.get_member(int(mid))
                        if member and guild_role not in member.roles:
                            await member.add_roles(guild_role, reason="Ğ ĞµÑ‚Ñ€Ğ¾Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ")
                            applied_members += 1
                    except Exception as e:
                        print(f"[applyretro] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ»Ñ Ñ‡Ğ»ĞµĞ½Ğ° {mid}: {e}")
                    
                    await asyncio.sleep(0.1)  # Rate limit
                    
            except Exception as e:
                print(f"[applyretro] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ğº Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ {gid}: {e}")
        
        await msg.edit(content=f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾!\n"
                               f"> Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ Ñ€Ğ¾Ğ»ĞµĞ¹: **{created_roles}**\n"
                               f"> ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼: **{applied_members}**")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ° ĞšĞĞ—Ğ˜ĞĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="blackjack", aliases=["bj"])
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def blackjack(self, ctx: commands.Context, bet: str = "100"):
        """ğŸƒ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ±Ğ»ÑĞºĞ´Ğ¶ĞµĞº! !bj all|half|25% Ğ¸Ğ»Ğ¸ !bj 1000"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ bet Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°
        if bet.lower() == "all":
            bet_amount = coins
        elif bet.lower() == "half":
            bet_amount = coins // 2
        elif bet.lower().endswith("%"):
            try:
                percent = int(bet[:-1])
                bet_amount = max(1, int(coins * percent / 100))
            except ValueError:
                await ctx.send(embed=ce("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", "> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: all | half | 25% | 1000", ctx.guild, 0xFF0000), delete_after=10)
                return
        else:
            try:
                bet_amount = int(bet)
            except ValueError:
                await ctx.send(embed=ce("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°", "> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: all | half | 25% | 1000", ctx.guild, 0xFF0000), delete_after=10)
                return
        
        if bet_amount < 50 or bet_amount > 100000:
            await ctx.send(embed=ce("ğŸƒ Ğ‘Ğ»ÑĞºĞ´Ğ¶ĞµĞº", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ°: **50-100,000** Ğ¼Ğ¾Ğ½ĞµÑ‚!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet_amount:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet_amount:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ğŸ´ ĞšĞĞ Ğ¢Ğ«
        suits = ["â™ ï¸", "â™¥ï¸", "â™¦ï¸", "â™£ï¸"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"]
        deck = [(r, s) for r in ranks for s in suits] * 4
        
        def card_value(card):
            rank = card[0]
            if rank in ["J", "Q", "K"]:
                return 10
            elif rank == "A":
                return 11
            else:
                return int(rank)
        
        def hand_value(hand):
            total = sum(card_value(c) for c in hand)
            aces = sum(1 for c in hand if c[0] == "A")
            while total > 21 and aces > 0:
                total -= 10
                aces -= 1
            return total
        
        def format_hand(hand):
            return " ".join(f"{c[0]}{c[1]}" for c in hand)
        
        # Ğ Ğ°Ğ·Ğ´Ğ°Ñ‡Ğ°
        random.shuffle(deck)
        player_hand = [deck.pop(), deck.pop()]
        dealer_hand = [deck.pop(), deck.pop()]
        
        class BlackjackView(disnake.ui.View):
            def __init__(self, deck, player_hand, dealer_hand, bet_amount, coins, ctx_author_id, author_name):
                super().__init__(timeout=30)
                self.deck = deck
                self.player_hand = player_hand
                self.dealer_hand = dealer_hand
                self.bet_amount = bet_amount
                self.coins = coins
                self.ctx_author_id = ctx_author_id
                self.author_name = author_name
                self.game_over = False
            
            def make_embed(self, show_dealer=False, guild_name="Ğ¡ĞµÑ€Ğ²ĞµÑ€"):
                player_val = hand_value(self.player_hand)
                dealer_val = hand_value(self.dealer_hand) if show_dealer else hand_value([self.dealer_hand[0]])
                
                if show_dealer:
                    dealer_cards = format_hand(self.dealer_hand)
                    dealer_info = f"Ğ”Ğ¸Ğ»ĞµÑ€ | {dealer_val}\n{dealer_cards}"
                else:
                    dealer_cards = f"{self.dealer_hand[0][0]}{self.dealer_hand[0][1]} ğŸ”’"
                    dealer_info = f"Ğ”Ğ¸Ğ»ĞµÑ€ | ?\n{dealer_cards}"
                
                description = (
                    f"**{self.author_name}** | {player_val}\n"
                    f"{format_hand(self.player_hand)}\n"
                    f"_ _\n"
                    f"{dealer_info}\n"
                    f"_ _\n"
                    f"Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ {guild_name}\n"
                    f"Ğ¡Ñ‚Ğ°Ğ²ĞºĞ°: ğŸ’° {self.bet_amount:,}"
                )
                
                embed = disnake.Embed(
                    title="ğŸƒ Ğ‘Ğ»ÑĞºĞ´Ğ¶ĞµĞº",
                    description=description,
                    color=0xFF6B9D
                )
                return embed
            
            async def update_embed(self, msg, show_dealer=False):
                embed = self.make_embed(show_dealer, guild_name="Ğ¡ĞµÑ€Ğ²ĞµÑ€")
                await msg.edit(embed=embed, view=self)
            
            @disnake.ui.button(label="Ğ£Ğ´Ğ°Ñ€ | Ğ’Ğ¾Ğ·ÑŒĞ¼Ğ¸ Ğ´Ñ€ÑƒĞ³ÑƒÑ ĞºĞ°Ñ€Ñ‚Ñƒ", style=disnake.ButtonStyle.primary)
            async def hit_button(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
                if inter.author.id != self.ctx_author_id:
                    await inter.response.defer()
                    return
                
                self.player_hand.append(self.deck.pop())
                player_val = hand_value(self.player_hand)
                
                if player_val > 21:
                    # ĞŸĞµÑ€ĞµĞ±Ğ¾Ñ€
                    save_user(str(self.ctx_author_id), str(inter.guild.id), {"coins": self.coins - self.bet_amount})
                    embed = disnake.Embed(
                        title="ğŸ’¥ ĞŸĞ•Ğ Ğ•Ğ‘ĞĞ !",
                        description=(
                            f"**{self.author_name}** | {player_val}\n"
                            f"{format_hand(self.player_hand)}\n"
                            f"_ _\n"
                            f"âŒ **-{self.bet_amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
                            f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{self.coins - self.bet_amount:,}**"
                        ),
                        color=0xFF0000
                    )
                    self.game_over = True
                    for item in self.children:
                        item.disabled = True
                    await inter.response.edit_message(embed=embed, view=self)
                else:
                    await inter.response.defer()
                    embed = self.make_embed(show_dealer=False, guild_name="Ğ¡ĞµÑ€Ğ²ĞµÑ€")
                    await inter.message.edit(embed=embed)
            
            @disnake.ui.button(label="Ğ¡Ñ‚Ğ¾ÑÑ‚ÑŒ | Ğ¡Ñ‚Ğ¾Ğ¿", style=disnake.ButtonStyle.danger)
            async def stand_button(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
                if inter.author.id != self.ctx_author_id:
                    await inter.response.defer()
                    return
                
                await inter.response.defer()
                
                # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ´Ğ¸Ğ»ĞµÑ€Ğ°
                dealer_val = hand_value(self.dealer_hand)
                while dealer_val < 17:
                    self.dealer_hand.append(self.deck.pop())
                    dealer_val = hand_value(self.dealer_hand)
                
                player_val = hand_value(self.player_hand)
                
                # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
                if dealer_val > 21:
                    result = "Ğ”Ğ˜Ğ›Ğ•Ğ  ĞŸĞ•Ğ Ğ•Ğ‘Ğ ĞĞ›!"
                    winnings = int(self.bet_amount * 2)
                    new_coins = self.coins + winnings
                    color = 0x00FF00
                    profit_text = f"âœ… **+{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
                elif player_val > dealer_val:
                    result = "Ğ¢Ğ« Ğ’Ğ«Ğ˜Ğ“Ğ ĞĞ›!"
                    winnings = int(self.bet_amount * 2)
                    new_coins = self.coins + winnings
                    color = 0x00FF00
                    profit_text = f"âœ… **+{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
                elif player_val < dealer_val:
                    result = "Ğ”Ğ˜Ğ›Ğ•Ğ  Ğ’Ğ«Ğ˜Ğ“Ğ ĞĞ›"
                    new_coins = self.coins - self.bet_amount
                    color = 0xFF0000
                    profit_text = f"âŒ **-{self.bet_amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
                else:
                    result = "ĞĞ˜Ğ§Ğ¬Ğ¯!"
                    new_coins = self.coins
                    color = 0xFFFF00
                    profit_text = "ğŸ¤ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ‚Ğ°Ğ²ĞºĞ¸"
                
                save_user(str(self.ctx_author_id), str(inter.guild.id), {"coins": new_coins})
                
                embed = disnake.Embed(
                    title=f"ğŸ° {result}",
                    description=(
                        f"**{self.author_name}** | {player_val}\n"
                        f"{format_hand(self.player_hand)}\n"
                        f"_ _\n"
                        f"Ğ”Ğ¸Ğ»ĞµÑ€ | {dealer_val}\n"
                        f"{format_hand(self.dealer_hand)}\n"
                        f"_ _\n"
                        f"{profit_text}\n"
                        f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
                    ),
                    color=color
                )
                self.game_over = True
                for item in self.children:
                    item.disabled = True
                await inter.message.edit(embed=embed, view=self)
        
        # ĞŸĞ¾ĞºĞ°Ğ· Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        embed = disnake.Embed(
            title="ğŸƒ Ğ‘Ğ»ÑĞºĞ´Ğ¶ĞµĞº",
            description=(
                f"**{ctx.author.name}** | {hand_value(player_hand)}\n"
                f"{format_hand(player_hand)}\n"
                f"_ _\n"
                f"Ğ”Ğ¸Ğ»ĞµÑ€ | ?\n"
                f"{dealer_hand[0][0]}{dealer_hand[0][1]} ğŸ”’\n"
                f"_ _\n"
                f"Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ {ctx.guild.name}\n"
                f"Ğ¡Ñ‚Ğ°Ğ²ĞºĞ°: ğŸ’° {bet_amount:,}"
            ),
            color=0xFF6B9D
        )
        
        view = BlackjackView(deck, player_hand, dealer_hand, bet_amount, coins, ctx.author.id, ctx.author.name)
        msg = await ctx.send(embed=embed, view=view)
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° blackjack
        if hand_value(player_hand) == 21:
            winnings = int(bet_amount * 2.5)
            new_coins = coins + winnings
            save_user(uid, sid, {"coins": new_coins})
            embed = disnake.Embed(
                title="ğŸ‰ ĞĞĞ¢Ğ£Ğ ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ‘Ğ›Ğ­ĞšĞ”Ğ–Ğ•Ğš!",
                description=(
                    f"**{ctx.author.name}** | 21\n"
                    f"{format_hand(player_hand)}\n"
                    f"_ _\n"
                    f"âœ… **+{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!\n"
                    f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
                ),
                color=0x00FF00
            )
            for item in view.children:
                item.disabled = True
            await msg.edit(embed=embed, view=view)

    @commands.command(name="slots")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def slots(self, ctx: commands.Context, bet: int = 100):
        """ğŸ’ ĞšÑ€ÑƒÑ‚Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ñ‚Ñ‹! ĞŸĞ¾Ğ¿Ğ°Ğ´Ğ¸ Ğ² ĞºĞ¾Ğ¼Ğ±Ğ¾ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ñ‹ÑˆĞ°."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if bet < 25 or bet > 150000:
            await ctx.send(embed=ce("ğŸ’ Ğ¡Ğ»Ğ¾Ñ‚Ñ‹", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **25** Ğ´Ğ¾ **150,000**!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        reels = [random.choice(["ğŸ’","ğŸŠ","ğŸ‹","â­","ğŸ’"]) for _ in range(3)]
        
        if reels[0] == reels[1] == reels[2]:
            winnings = int(bet * 5)
            result = "ğŸŠ Ğ”Ğ–Ğ•ĞšĞŸĞĞ¢! Ğ’Ğ¡Ğ• Ğ¢Ğ Ğ˜!"
        elif reels[0] == reels[1] or reels[1] == reels[2]:
            winnings = int(bet * 2)
            result = "â­ Ğ”Ğ²Ğ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ!"
        else:
            winnings = 0
            result = "âŒ ĞĞµ Ğ¿Ğ¾Ğ²ĞµĞ·Ğ»Ğ¾"
        
        new_coins = coins + winnings - bet if winnings > 0 else coins - bet
        save_user(uid, sid, {"coins": new_coins})
        
        desc = f"> {' '.join(reels)}\n> {result}\n"
        if winnings > 0:
            desc += f"> ğŸ **+{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
        else:
            desc += f"> ĞŸĞ¾Ñ‚ĞµÑ€ÑĞ½Ğ¾ **-{bet:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        desc += f"\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("ğŸ’ Ğ¡Ğ»Ğ¾Ñ‚Ñ‹", desc, ctx.guild, 0x2ECC71 if winnings > 0 else 0xE74C3C))

    @commands.command(name="coinflip", aliases=["cf"])
    @commands.cooldown(1, 3, commands.BucketType.user)
    async def coinflip(self, ctx: commands.Context, bet: int = 100, choice: str = "heads"):
        """ğŸª™ ĞÑ€Ñ‘Ğ» Ğ¸Ğ»Ğ¸ Ñ€ĞµÑˆĞºĞ°? Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ heads/h/Ğ¾Ñ€ĞµĞ» Ğ¸Ğ»Ğ¸ tails/t/Ñ€ĞµÑˆĞºĞ°."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if bet < 50 or bet > 200000:
            await ctx.send(embed=ce("ğŸª™ ĞÑ€Ñ‘Ğ»-Ğ ĞµÑˆĞºĞ°", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **50** Ğ´Ğ¾ **200,000**!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        result = random.choice(["Ğ¾Ñ€ĞµĞ»", "Ñ€ĞµÑˆĞºĞ°"])
        choice = choice.lower()
        win = (choice in ["Ğ¾Ñ€ĞµĞ»", "heads", "h", "Ğ¾"] and result == "Ğ¾Ñ€ĞµĞ»") or \
              (choice in ["Ñ€ĞµÑˆĞºĞ°", "tails", "t", "Ñ€"] and result == "Ñ€ĞµÑˆĞºĞ°")
        
        if win:
            winnings = bet
            new_coins = coins + winnings
            emoji = "ğŸª™ ĞĞ Ğ•Ğ›!" if result == "Ğ¾Ñ€ĞµĞ»" else "ğŸª™ Ğ Ğ•Ğ¨ĞšĞ!"
        else:
            new_coins = coins - bet
            emoji = "âš ï¸ ĞĞµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ»Ğ¾!"
        
        save_user(uid, sid, {"coins": new_coins})
        
        desc = f"> Ğ’Ñ‹Ğ¿Ğ°Ğ»Ğ¾: **{result.upper()}**\n> {emoji}\n"
        if win:
            desc += f"> ğŸ‰ **+{bet:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
        else:
            desc += f"> âŒ **-{bet:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        desc += f"\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("ğŸª™ ĞÑ€Ñ‘Ğ»-Ğ ĞµÑˆĞºĞ°", desc, ctx.guild, 0x2ECC71 if win else 0xE74C3C))

    @commands.command(name="roulette", aliases=["rle"])
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def roulette(self, ctx: commands.Context, bet: int = 100, choice: str = "red"):
        """ğŸ¡ Ğ ÑƒĞ»ĞµÑ‚ĞºĞ°! Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ red, black Ğ¸Ğ»Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ¾ 1-36."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if bet < 100 or bet > 50000:
            await ctx.send(embed=ce("ğŸ¡ Ğ ÑƒĞ»ĞµÑ‚ĞºĞ°", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **100** Ğ´Ğ¾ **50,000**!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        spin = random.randint(1, 36)
        red_nums = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]
        
        choice = choice.lower()
        win = False
        winnings = 0
        result_color = "âš« Ğ§Ñ‘Ñ€Ğ½Ñ‹Ğ¹" if spin not in red_nums else "ğŸ”´ ĞšÑ€Ğ°ÑĞ½Ñ‹Ğ¹"
        
        if choice in ["red", "ĞºÑ€Ğ°ÑĞ½Ñ‹Ğ¹", "Ğº"]:
            is_red = spin in red_nums
            if is_red:
                win = True
                winnings = int(bet * 2.5)
        elif choice in ["black", "Ñ‡Ñ‘Ñ€Ğ½Ñ‹Ğ¹", "Ñ‡Ñ‘Ñ€", "Ñ‡"]:
            is_red = spin in red_nums
            if not is_red:
                win = True
                winnings = int(bet * 2.5)
        else:
            try:
                num = int(choice)
                if num == spin:
                    win = True
                    winnings = int(bet * 36)
            except ValueError:
                await ctx.send(embed=ce("âŒ", "> Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ red, black Ğ¸Ğ»Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ¾ 1-36!", ctx.guild, 0xFF0000), delete_after=10)
                return
        
        new_coins = coins + (winnings - bet) if win else coins - bet
        save_user(uid, sid, {"coins": new_coins})
        
        desc = f"> ğŸ¡ Ğ§Ğ¸ÑĞ»Ğ¾: **{spin}** {result_color}\n"
        if win:
            desc += f"> ğŸ‰ **Ğ¢Ğ« Ğ’Ğ«Ğ˜Ğ“Ğ ĞĞ›! +{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
        else:
            desc += f"> âŒ ĞŸÑ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ğ» **-{bet:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        desc += f"\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("ğŸ¡ Ğ ÑƒĞ»ĞµÑ‚ĞºĞ°", desc, ctx.guild, 0x2ECC71 if win else 0xE74C3C))

    @commands.command(name="dice")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def dice(self, ctx: commands.Context, bet: int = 100):
        """ğŸ² ĞšÑƒĞ±Ğ¸ĞºĞ¸! Ğ¢Ğ²Ğ¾Ğ¸ ĞºÑƒĞ±Ğ¸ĞºĞ¸ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ² Ğ±Ğ¾Ñ‚Ğ° (Ğ²Ñ‹ÑˆĞµ = Ğ¿Ğ¾Ğ±ĞµĞ´Ğ°)."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if bet < 50 or bet > 75000:
            await ctx.send(embed=ce("ğŸ² ĞšÑƒĞ±Ğ¸ĞºĞ¸", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **50** Ğ´Ğ¾ **75,000**!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        player_dice = random.randint(1, 100)
        bot_dice = random.randint(1, 100)
        
        if player_dice > bot_dice:
            win = True
            result_text = "**âœ… Ğ¢Ğ« Ğ’Ğ«Ğ˜Ğ“Ğ ĞĞ›!**"
            color = 0x2ECC71
        elif player_dice < bot_dice:
            win = False
            result_text = "**âŒ Ğ¢Ğ« ĞŸĞ ĞĞ˜Ğ“Ğ ĞĞ›!**"
            color = 0xE74C3C
        else:
            win = False
            result_text = "**ğŸ¤ ĞĞ˜Ğ§Ğ¬Ğ¯!**"
            color = 0xFFFF00
        
        if win:
            new_coins = coins + bet
            winnings = bet
        elif player_dice == bot_dice:
            new_coins = coins  # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ÑÑ‚Ğ°Ğ²ĞºĞ¸
            winnings = 0
        else:
            new_coins = coins - bet
            winnings = -bet
        
        save_user(uid, sid, {"coins": new_coins})
        
        desc = f"> ğŸ² Ğ¢Ğ²Ğ¾Ğ¸ ĞºÑƒĞ±Ğ¸ĞºĞ¸: **{player_dice}**\n> ğŸ² ĞšÑƒĞ±Ğ¸ĞºĞ¸ Ğ±Ğ¾Ñ‚Ğ°: **{bot_dice}**\n> {result_text}\n"
        if winnings > 0:
            desc += f"> ğŸ‰ **+{winnings:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!"
        elif winnings < 0:
            desc += f"> âŒ **-{abs(winnings):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        else:
            desc += f"> â†©ï¸ Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ°"
        desc += f"\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("ğŸ² ĞšÑƒĞ±Ğ¸ĞºĞ¸", desc, ctx.guild, color))

    @commands.command(name="wheel", aliases=["w"])
    @commands.cooldown(1, 8, commands.BucketType.user)
    async def wheel(self, ctx: commands.Context, bet: int = 100):
        """ğŸ¡ ĞšÑ€ÑƒÑ‚Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»ĞµÑĞ¾ Ñ„Ğ¾Ñ€Ñ‚ÑƒĞ½Ñ‹! 50x Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸Ğ¿Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€!"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if bet < 50 or bet > 200000:
            await ctx.send(embed=ce("ğŸ¡ ĞšĞ¾Ğ»ĞµÑĞ¾", 
                                     "> Ğ¡Ñ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **50** Ğ´Ğ¾ **200,000**!", 
                                     ctx.guild, 0xFF8800), delete_after=10)
            return
        
        if coins < bet:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{bet:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        WHEEL = {
            "ğŸ’€": {"mult": 0, "chance": 30},
            "ğŸ”´": {"mult": 0.5, "chance": 22},
            "âšª": {"mult": 1, "chance": 19},
            "ğŸŒ¸": {"mult": 2, "chance": 18},
            "ğŸŸ¢": {"mult": 3, "chance": 7},
            "ğŸŸ¡": {"mult": 5, "chance": 2.5},
            "ğŸ’œ": {"mult": 10, "chance": 1.3},
            "â­": {"mult": 50, "chance": 0.2},
        }
        
        embed = disnake.Embed(title="ğŸ¡ ĞšĞ¾Ğ»ĞµÑĞ¾ ĞšÑ€ÑƒÑ‚Ğ¸Ñ‚ÑÑ...", 
                              description="> ğŸ¡ ğŸ¡ ğŸ¡\n> *ĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚...*", 
                              color=0xFF69B4)
        msg = await ctx.send(embed=embed)
        await asyncio.sleep(2)
        
        roll = random.uniform(0, 100)
        cumulative = 0
        result_emoji = "âšª"
        
        for emoji, data in WHEEL.items():
            cumulative += data["chance"]
            if roll <= cumulative:
                result_emoji = emoji
                break
        
        mult = WHEEL[result_emoji]["mult"]
        profit = int(bet * mult) - bet
        new_coins = coins + profit
        save_user(uid, sid, {"coins": new_coins})
        
        if profit > 0:
            color = 0x2ECC71
            res_text = f"ğŸ‰ Ğ’Ğ«Ğ˜Ğ“Ğ Ğ«Ğ¨! **+{profit:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ (x{mult})"
        elif profit == 0:
            color = 0xFFFF00
            res_text = f"â¡ï¸ Ğ’ĞµÑ€Ğ½ÑƒĞ»Ğ¸ ÑÑ‚Ğ°Ğ²ĞºÑƒ (x{mult})"
        else:
            color = 0xE74C3C
            res_text = f"ğŸ˜ ĞŸĞ¾Ñ‚ĞµÑ€Ñ **-{abs(profit):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ (x{mult})"
        
        embed = disnake.Embed(title="ğŸ¡ ĞšĞ¾Ğ»ĞµÑĞ¾ ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ!", 
                              description=f"> {result_emoji} **x{mult}**\n> _ _\n> {res_text}\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**", 
                              color=color)
        await msg.edit(embed=embed)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š Ğ Ğ«ĞĞĞš Ğ˜ Ğ¢ĞĞ Ğ“ĞĞ’Ğ›Ğ¯
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="market")
    async def market(self, ctx: commands.Context):
        """ğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ñ†ĞµĞ½Ñ‹ Ğ½Ğ° Ñ€Ñ‹Ğ½ĞºĞµ."""
        from economy import MARKET_GOODS
        import random
        
        desc = ""
        for good_key, good in MARKET_GOODS.items():
            base = good["base_price"]
            # Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ ĞºĞ¾Ğ»ĞµĞ±Ğ°Ğ½Ğ¸Ñ Ñ†ĞµĞ½Ñ‹
            variance = random.uniform(-good["volatility"], good["volatility"])
            current_price = int(base * (1 + variance))
            arrow = "ğŸ“ˆ" if current_price > base else "ğŸ“‰" if current_price < base else "â¡ï¸"
            desc += f"> {good['emoji']} {good['name']}: **{current_price:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ {arrow}\n"
        
        await ctx.send(embed=ce("ğŸ“Š Ğ Ñ‹Ğ½Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¦ĞµĞ½Ñ‹", desc, ctx.guild, 0x3498DB))

    @commands.command(name="invest")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def invest(self, ctx: commands.Context, plan: str = "short_term", amount: int = 10000):
        """ğŸ¦ Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ¿Ğ»Ğ°Ğ½. Ğ’Ñ‹Ğ±Ğ¾Ñ€: short_term, medium_term, long_term, guild_fund"""
        from economy import INVESTMENT_PLANS
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if plan not in INVESTMENT_PLANS:
            await ctx.send(embed=ce("âŒ", f"> ĞŸĞ»Ğ°Ğ½ '{plan}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        inv_plan = INVESTMENT_PLANS[plan]
        if amount < inv_plan["min_investment"] or amount > inv_plan["max_investment"]:
            await ctx.send(embed=ce("âŒ", 
                f"> Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¾Ñ‚ **{inv_plan['min_investment']:,}** Ğ´Ğ¾ **{inv_plan['max_investment']:,}**!", 
                ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if coins < amount:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{amount:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ
        apy = inv_plan["apy"]
        days = inv_plan["duration_days"]
        profit = int(amount * apy * (days / 365))
        
        new_coins = coins - amount
        save_user(uid, sid, {"coins": new_coins})
        
        desc = f"> {inv_plan['emoji']} {inv_plan['name']}\n"
        desc += f"> Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾: **{amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ğŸ“ˆ Ğ“Ğ¾Ğ´Ğ¾Ğ²Ğ°Ñ Ğ´Ğ¾Ñ…Ğ¾Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ: **{apy*100:.0f}%**\n"
        desc += f"> ğŸ’° ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ: **+{profit:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ğŸ“… Ğ¡Ñ€Ğ¾Ğº: **{days} Ğ´Ğ½ĞµĞ¹**\n"
        desc += f"> Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚: **{amount + profit:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        
        await ctx.send(embed=ce("ğŸ¦ Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ñ", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="lottery")
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def lottery(self, ctx: commands.Context, ticket_type: str = "common"):
        """ğŸ« ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ñ‚ĞµÑ€ĞµĞ¹Ğ½Ñ‹Ğ¹ Ğ±Ğ¸Ğ»ĞµÑ‚! Ğ¢Ğ¸Ğ¿Ñ‹: common, rare, epic, legendary"""
        from economy import LOTTERY_TICKETS
        import random
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if ticket_type not in LOTTERY_TICKETS:
            await ctx.send(embed=ce("âŒ", "> ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        ticket = LOTTERY_TICKETS[ticket_type]
        if coins < ticket["price"]:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{ticket['price']:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ Ğ¾Ğ·Ñ‹Ğ³Ñ€Ñ‹Ñˆ
        win = random.random() < 0.25  # 25% ÑˆĞ°Ğ½Ñ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ñ‹ÑˆĞ°
        
        if win:
            prize = random.randint(int(ticket["avg_win"] * 0.5), ticket["max_win"])
            new_coins = coins - ticket["price"] + prize
            desc = f"> {ticket['emoji']} ĞĞ³Ğ¾! Ğ¢Ñ‹ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ğ°Ğ»!\n> ğŸ **+{prize:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚!\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        else:
            new_coins = coins - ticket["price"]
            desc = f"> {ticket['emoji']} ĞĞµ Ğ¿Ğ¾Ğ²ĞµĞ·Ğ»Ğ¾ Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ñ€Ğ°Ğ·...\n> ĞŸĞ¾Ñ‚ĞµÑ€ÑĞ½Ğ¾ **-{ticket['price']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        save_user(uid, sid, {"coins": new_coins})
        
        await ctx.send(embed=ce(ticket["name"], desc, ctx.guild, 0x2ECC71 if win else 0xE74C3C))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŠ Ğ•Ğ–Ğ•Ğ”ĞĞ•Ğ’ĞĞ«Ğ• ĞšĞ’Ğ•Ğ¡Ğ¢Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="quests")
    async def quests(self, ctx: commands.Context):
        """ğŸŠ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ ĞºĞ²ĞµÑÑ‚Ñ‹ Ğ¸ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹."""
        from economy import DAILY_QUESTS
        
        desc = ""
        for q in DAILY_QUESTS:
            desc += f"> {q['emoji']} **{q['title']}**\n"
            desc += f"  _{q['description']}_\n"
            desc += f"  Ğ¦ĞµĞ»ÑŒ: **{q['goal']}** | ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{q['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n\n"
        
        await ctx.send(embed=ce("ğŸŠ Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ ĞšĞ²ĞµÑÑ‚Ñ‹", desc, ctx.guild, 0x9B59B6))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # âš”ï¸ Ğ‘ĞĞ•Ğ’ĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="army")
    async def army(self, ctx: commands.Context):
        """âš”ï¸ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ°Ñ€Ğ¼Ğ¸Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        if not gd:
            return
        
        army = gd.get("army", {})
        total_power = sum(ARMY_UNITS[u]["power"] * c for u, c in army.items() if u in ARMY_UNITS)
        
        desc = f"**[{gd['tag']}] {gd['name']}**\n> _ _\n"
        for unit_key, unit_data in ARMY_UNITS.items():
            count = army.get(unit_key, 0)
            power_val = unit_data["power"] * count
            if count > 0:
                desc += f"> {unit_data['emoji']} {unit_data['name']}: **{count}** (Ğ¼Ğ¾Ñ‰ÑŒ: **{power_val}**)\n"
        
        desc += f"\n> **ĞĞ±Ñ‰Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ: {total_power}**"
        tech = gd.get("technologies", [])
        if "iron_infantry" in tech:
            total_power = int(total_power * 1.2)
            desc += f"\n> ğŸ—ï¸ Ğ¡ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸ĞµĞ¹ Ğ–ĞµĞ»ĞµĞ·Ğ½Ğ°Ñ Ğ¿ĞµÑ…Ğ¾Ñ‚Ğ°: **{total_power}**"
        
        await ctx.send(embed=ce("âš”ï¸ ĞÑ€Ğ¼Ğ¸Ñ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", desc, ctx.guild, 0xE74C3C))

    @commands.command(name="recruit")
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def recruit(self, ctx: commands.Context, unit: str = "recruit", amount: int = 1):
        """âš”ï¸ ĞĞ°Ğ½ÑÑ‚ÑŒ Ğ²Ğ¾Ğ¹ÑĞºĞ°. Ğ¢Ğ¸Ğ¿Ñ‹: recruit, soldier, knight, champion, legend"""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if unit not in ARMY_UNITS:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ°ĞºĞ¾Ğ³Ğ¾ ÑĞ½Ğ¸Ñ‚Ğ° Ğ½ĞµÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        unit_data = ARMY_UNITS[unit]
        total_cost = unit_data["cost"] * amount
        
        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ
        gd = get_guild(gid)
        if "supply_chain" in gd.get("technologies", []):
            total_cost = int(total_cost * 0.8)
        
        if coins < total_cost:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{total_cost:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞĞ°Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ²Ğ¾Ğ¹ÑĞºĞ°
        army = gd.get("army", {})
        army[unit] = army.get(unit, 0) + amount
        save_guild(gid, {"army": army})
        save_user(uid, sid, {"coins": coins - total_cost})
        
        desc = f"> {unit_data['emoji']} **{unit_data['name']}** Ã— {amount}\n"
        desc += f"> Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{total_cost:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: **{coins - total_cost:,}**"
        
        await ctx.send(embed=ce(f"âœ… ĞĞ°Ğ½ÑÑ‚Ğ¾ Ğ²Ğ¾Ğ¹ÑĞº!", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="attack")
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def attack(self, ctx: commands.Context, target_tag: str, attack_type: str = "raid"):
        """âš”ï¸ ĞĞ°Ğ¿Ğ°ÑÑ‚ÑŒ Ğ½Ğ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ! Ğ¢Ğ¸Ğ¿Ñ‹: raid, siege, conquest"""
        import random
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ°
        if u.get("guild_rank") not in ["owner", "viceowner", "officer"]:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ½Ğ°Ğ¿Ğ°Ğ´Ğ°Ñ‚ÑŒ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        if attack_type not in ATTACK_TYPES:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ°ĞºĞ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ° Ğ°Ñ‚Ğ°ĞºĞ¸ Ğ½ĞµÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        target_guild = guild_by_tag(sid, target_tag)
        if not target_guild:
            await ctx.send(embed=ce("âŒ", f"> Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ [{target_tag}] Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if target_guild["id"] == gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑˆÑŒ Ğ½Ğ°Ğ¿Ğ°ÑÑ‚ÑŒ Ğ½Ğ° ÑĞ²Ğ¾Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ
        attack_data = ATTACK_TYPES[attack_type]
        cost = attack_data["cost"]
        
        if coins < cost:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{cost:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¼Ğ¾Ñ‰ÑŒ
        attacker_power = sum(ARMY_UNITS[u]["power"] * c for u, c in gd.get("army", {}).items() if u in ARMY_UNITS)
        defender_power = sum(ARMY_UNITS[u]["power"] * c for u, c in target_guild.get("army", {}).items() if u in ARMY_UNITS)
        
        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸
        if "iron_infantry" in gd.get("technologies", []):
            attacker_power = int(attacker_power * 1.2)
        if "shield_mastery" in target_guild.get("technologies", []):
            defender_power = int(defender_power * 1.3)
        if "fortifications" in target_guild.get("technologies", []):
            defender_power = int(defender_power * 1.4)
        
        attacker_power = max(1, attacker_power)
        defender_power = max(1, defender_power)
        
        # Ğ‘Ğ¾ĞµĞ²Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
        attacker_roll = random.randint(1, 100) + (attacker_power // 10)
        defender_roll = random.randint(1, 100) + (defender_power // 10)
        
        win = attacker_roll > defender_roll
        
        loot_amount = 0
        if win:
            target_bank = target_guild.get("bank", 0)
            # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ ÑƒĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ñ‹
            if "fortifications" in target_guild.get("technologies", []):
                loot_amount = int(target_bank * attack_data["loot_percent"] * 0.6)  # -40% Ğ¾Ñ‚ ÑƒĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ğ¹
            else:
                loot_amount = int(target_bank * attack_data["loot_percent"])
            
            new_bank = max(0, target_bank - loot_amount)
            save_guild(target_guild["id"], {"bank": new_bank})
            save_user(uid, sid, {"coins": coins - cost + loot_amount})
            
            desc = f"> âœ… **ĞŸĞĞ‘Ğ•Ğ”Ğ!**\n> {attack_data['emoji']} {attack_data['name']}\n"
            desc += f"> ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº: **[{target_guild['tag']}]**\n"
            desc += f"> ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ: **+{loot_amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: **{coins - cost + loot_amount:,}**"
            color = 0x2ECC71
        else:
            save_user(uid, sid, {"coins": coins - cost})
            desc = f"> âŒ **ĞŸĞĞ ĞĞ–Ğ•ĞĞ˜Ğ•!**\n> {attack_data['emoji']} {attack_data['name']}\n"
            desc += f"> ĞŸÑ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğº: **[{target_guild['tag']}]**\n"
            desc += f"> ĞŸĞ¾Ñ‚ĞµÑ€Ñ: **-{cost:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ: **{coins - cost:,}**"
            color = 0xE74C3C
        
        await ctx.send(embed=ce("âš”ï¸ Ğ‘Ğ¾ĞµĞ²Ğ¾Ğ¹ Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚", desc, ctx.guild, color))

    @commands.command(name="tech")
    async def tech(self, ctx: commands.Context):
        """ğŸ”¬ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ¸ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        tech_list = gd.get("technologies", [])
        coins = gd.get("bank", 0)
        
        desc = ""
        for tech_key, tech_data in TECHNOLOGIES.items():
            status = "âœ… ĞšÑƒĞ¿Ğ»ĞµĞ½Ğ°" if tech_key in tech_list else f"ğŸ”’ {tech_data['cost']:,} Ğ¼Ğ¾Ğ½ĞµÑ‚"
            desc += f"> {tech_data['name']}\n"
            desc += f"  {tech_data['description']}\n"
            desc += f"  {status}\n\n"
        
        desc += f"Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ ĞºĞ°Ğ·Ğ½Ñ‹: **{coins:,}**"
        await ctx.send(embed=ce("ğŸ”¬ Ğ¢ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", desc, ctx.guild, 0x9B59B6))

    @commands.command(name="buytech")
    @commands.cooldown(1, 20, commands.BucketType.user)
    async def buytech(self, ctx: commands.Context, tech_name: str):
        """ğŸ”¬ ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if u.get("guild_rank") != "owner":
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ğ¾ĞºÑƒĞ¿Ğ°Ñ‚ÑŒ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if tech_name not in TECHNOLOGIES:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ°ĞºĞ¾Ğ¹ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        tech_list = gd.get("technologies", [])
        if tech_name in tech_list:
            await ctx.send(embed=ce("âŒ", "> Ğ­Ñ‚Ğ° Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ ÑƒĞ¶Ğµ ĞºÑƒĞ¿Ğ»ĞµĞ½Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        tech_data = TECHNOLOGIES[tech_name]
        bank = gd.get("bank", 0)
        
        if bank < tech_data["cost"]:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ² ĞºĞ°Ğ·Ğ½Ğµ",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{tech_data['cost']:,}**, Ğ° Ğ² ĞºĞ°Ğ·Ğ½Ğµ **{bank:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        tech_list.append(tech_name)
        save_guild(gid, {
            "technologies": tech_list,
            "bank": bank - tech_data["cost"]
        })
        
        desc = f"> {tech_data['name']}\n"
        desc += f"> {tech_data['description']}\n"
        desc += f"> Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{tech_data['cost']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ ĞºĞ°Ğ·Ğ½Ñ‹: **{bank - tech_data['cost']:,}**"
        
        await ctx.send(embed=ce("âœ… Ğ¢ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ ĞšÑƒĞ¿Ğ»ĞµĞ½Ğ°!", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="statss")
    async def statss(self, ctx: commands.Context):
        """ğŸ“Š Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ñ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¾Ğ¼."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        
        # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ´Ğ»Ñ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ°
        all_guilds = list(db["guilds"].find({"server_id": sid}))
        all_guilds = sorted(all_guilds, key=lambda x: x.get("bank", 0), reverse=True)
        
        rank = next((i+1 for i, g in enumerate(all_guilds) if g["id"] == gid), 0)
        total_guilds = len(all_guilds)
        
        # Ğ‘Ğ¾ĞµĞ²Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ
        army = gd.get("army", {})
        total_power = sum(ARMY_UNITS[u]["power"] * c for u, c in army.items() if u in ARMY_UNITS)
        
        desc = f"**[{gd['tag']}] {gd['name']}**\n> _ _\n"
        desc += f"> ğŸ‘‘ Ğ›Ğ¸Ğ´ĞµÑ€: <@{gd['owner_id']}>\n"
        desc += f"> ğŸ‘¥ Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: **{member_count(gid, sid)}**\n"
        desc += f"> ğŸ’° ĞšĞ°Ğ·Ğ½Ğ°: **{gd.get('bank', 0):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> âš”ï¸ Ğ‘Ğ¾ĞµĞ²Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ: **{total_power}**\n"
        desc += f"> ğŸ“ Ğ¢ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¹: **{len(gd.get('technologies', []))}**\n"
        desc += f"> ğŸ† ĞŸĞ¾Ğ±ĞµĞ´: **{gd.get('wins', 0)}** | ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹: **{gd.get('losses', 0)}**\n"
        desc += f"> ğŸ“Š ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğµ: **#{rank} Ğ¸Ğ· {total_guilds}**"
        
        await ctx.send(embed=ce("ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", desc, ctx.guild, 0x3498DB))

    @commands.command(name="achievements")
    async def achievements(self, ctx: commands.Context, user: Optional[disnake.Member] = None):
        """ğŸ† ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ."""
        from economy import ACHIEVEMENTS
        target = user or ctx.author
        uid, sid = str(target.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        
        coins = u.get("coins", 0)
        farms = len(u.get("farms", []))
        
        desc = ""
        for ach_key, ach in ACHIEVEMENTS.items():
            unlocked = False
            if ach_key == "millionaire" and coins >= 1000000:
                unlocked = True
            elif ach_key == "farmer" and farms >= 10:
                unlocked = True
            
            emoji = "âœ…" if unlocked else "ğŸ”’"
            desc += f"> {emoji} {ach['emoji']} **{ach['title']}**\n"
            desc += f"  {ach['description']}\n"
            if unlocked:
                desc += f"  ğŸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{ach['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n\n"
            else:
                desc += f"  Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾\n\n"
        
        await ctx.send(embed=ce("ğŸ† Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ", desc, ctx.guild, 0xF1C40F))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ’¼ Ğ Ğ«ĞĞĞš: ĞŸĞĞšĞ£ĞŸĞšĞ Ğ˜ ĞŸĞ ĞĞ”ĞĞ–Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="mbuy")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def market_buy(self, ctx: commands.Context, good: str = None, quantity: int = 1):
        """ğŸ’¼ ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ½Ğ° Ñ€Ñ‹Ğ½ĞºĞµ! mbuy [Ñ‚Ğ¾Ğ²Ğ°Ñ€] [ĞºĞ¾Ğ»-Ğ²Ğ¾]"""
        from economy import MARKET_GOODS
        import random
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        
        if not good or good not in MARKET_GOODS:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ²Ğ°Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½! mbuy ore 5", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        good_data = MARKET_GOODS[good]
        base = good_data["base_price"]
        variance = random.uniform(-good_data["volatility"], good_data["volatility"])
        current_price = int(base * (1 + variance))
        total_cost = current_price * quantity
        
        if coins < total_cost:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{total_cost:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºÑƒ Ğ² Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ
        inventory = u.get("market_inventory", {})
        inventory[good] = inventory.get(good, 0) + quantity
        new_coins = coins - total_cost
        save_user(uid, sid, {"coins": new_coins, "market_inventory": inventory})
        
        desc = f"> {good_data['emoji']} **{good_data['name']}** x{quantity}\n"
        desc += f"> Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ÑˆÑ‚: **{current_price:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: **-{total_cost:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ°", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="msell")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def market_sell(self, ctx: commands.Context, good: str = None, quantity: int = 1):
        """ğŸ’¼ ĞŸÑ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€! msell [Ñ‚Ğ¾Ğ²Ğ°Ñ€] [ĞºĞ¾Ğ»-Ğ²Ğ¾]"""
        from economy import MARKET_GOODS
        import random
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        inventory = u.get("market_inventory", {})
        
        if not good or good not in MARKET_GOODS:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ²Ğ°Ñ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if inventory.get(good, 0) < quantity:
            await ctx.send(embed=ce("âŒ", f"> Ğ£ Ñ‚ĞµĞ±Ñ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ **{inventory.get(good, 0)}** ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        good_data = MARKET_GOODS[good]
        base = good_data["base_price"]
        variance = random.uniform(-good_data["volatility"], good_data["volatility"])
        current_price = int(base * (1 + variance) * 0.95)  # 95% Ñ†ĞµĞ½Ñ‹ (ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ 5%)
        total_gain = current_price * quantity
        
        inventory[good] -= quantity
        new_coins = coins + total_gain
        save_user(uid, sid, {"coins": new_coins, "market_inventory": inventory})
        
        desc = f"> {good_data['emoji']} **{good_data['name']}** x{quantity}\n"
        desc += f"> Ğ¦ĞµĞ½Ğ° Ğ·Ğ° ÑˆÑ‚: **{current_price:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: **+{total_gain:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞŸÑ€Ğ¾Ğ´Ğ°Ğ¶Ğ°", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="minventory")
    async def market_inventory(self, ctx: commands.Context):
        """ğŸ’¼ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²."""
        from economy import MARKET_GOODS
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        inventory = u.get("market_inventory", {})
        
        if not inventory:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ²Ğ¾Ğ¹ Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¿ÑƒÑÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        desc = ""
        total_value = 0
        for good, qty in inventory.items():
            if good in MARKET_GOODS:
                good_data = MARKET_GOODS[good]
                est_value = good_data["base_price"] * qty
                total_value += est_value
                desc += f"> {good_data['emoji']} {good_data['name']}: x**{qty}** (~{est_value:,} Ğ¼Ğ¾Ğ½ĞµÑ‚)\n"
        
        desc += f"\n> ğŸ“Š ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ°Ñ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{total_value:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        await ctx.send(embed=ce("ğŸ’¼ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ", desc, ctx.guild, 0x3498DB))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¦ Ğ˜ĞĞ’Ğ•Ğ¡Ğ¢Ğ˜Ğ¦Ğ˜Ğ˜: ĞĞ¢Ğ¡Ğ›Ğ•Ğ–Ğ˜Ğ’ĞĞĞ˜Ğ• Ğ˜ Ğ’Ğ«Ğ’ĞĞ”
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="invests")
    async def investments(self, ctx: commands.Context):
        """ğŸ¦ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ²Ğ¾Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¸."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        inv_list = u.get("investments", [])
        
        if not inv_list:
            await ctx.send(embed=ce("âŒ", "> Ğ£ Ñ‚ĞµĞ±Ñ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¹!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        from datetime import datetime
        from economy import INVESTMENT_PLANS
        
        desc = ""
        now = datetime.utcnow().timestamp()
        
        for inv in inv_list:
            plan_key = inv.get("plan")
            plan = INVESTMENT_PLANS.get(plan_key, {})
            amount = inv.get("amount", 0)
            created = inv.get("created_at", now)
            end_time = created + (plan.get("duration_days", 0) * 86400)
            
            apy = plan.get("apy", 0)
            profit = int(amount * apy * (plan.get("duration_days", 0) / 365))
            
            time_left = max(0, end_time - now)
            days_left = int(time_left / 86400)
            
            status = "âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾!" if time_left <= 0 else f"â³ {days_left} Ğ´Ğ½ĞµĞ¹"
            desc += f"> {plan.get('emoji', 'ğŸ“†')} {plan.get('name', 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¿Ğ»Ğ°Ğ½')}\n"
            desc += f"> Ğ¡ÑƒĞ¼Ğ¼Ğ°: **{amount:,}** | ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ: **+{profit:,}** | {status}\n\n"
        
        await ctx.send(embed=ce("ğŸ¦ Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¸", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="iwithdraw")
    @commands.cooldown(1, 300, commands.BucketType.user)
    async def invest_withdraw(self, ctx: commands.Context, index: int = 0):
        """ğŸ¦ Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ñ! iwithdraw [Ğ½Ğ¾Ğ¼ĞµÑ€]"""
        from datetime import datetime
        from economy import INVESTMENT_PLANS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        inv_list = u.get("investments", [])
        coins = u.get("coins", 0)
        
        if not inv_list or index >= len(inv_list) or index < 0:
            await ctx.send(embed=ce("âŒ", "> Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        inv = inv_list[index]
        plan_key = inv.get("plan")
        plan = INVESTMENT_PLANS.get(plan_key, {})
        amount = inv.get("amount", 0)
        created = inv.get("created_at", datetime.utcnow().timestamp())
        end_time = created + (plan.get("duration_days", 0) * 86400)
        now = datetime.utcnow().timestamp()
        
        if now < end_time:
            days_left = int((end_time - now) / 86400)
            await ctx.send(embed=ce("âŒ", f"> ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ñ‡ĞµÑ€ĞµĞ· **{days_left}** Ğ´Ğ½ĞµĞ¹!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        apy = plan.get("apy", 0)
        profit = int(amount * apy * (plan.get("duration_days", 0) / 365))
        total_return = amount + profit
        
        new_coins = coins + total_return
        inv_list.pop(index)
        save_user(uid, sid, {"coins": new_coins, "investments": inv_list})
        
        desc = f"> Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾: **{amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ: **+{profit:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: **+{total_return:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ¡Ñ€ĞµĞ´ÑÑ‚Ğ²", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸŠ ĞšĞ’Ğ•Ğ¡Ğ¢Ğ«: ĞĞ¢Ğ¡Ğ›Ğ•Ğ–Ğ˜Ğ’ĞĞĞ˜Ğ• Ğ˜ ĞŸĞĞ›Ğ£Ğ§Ğ•ĞĞ˜Ğ• ĞĞĞ“Ğ ĞĞ”
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="qclaim")
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def quest_claim(self, ctx: commands.Context, quest_id: str = None):
        """ğŸŠ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ·Ğ° ĞºĞ²ĞµÑÑ‚! qclaim [id]"""
        from economy import DAILY_QUESTS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        quest_progress = u.get("quest_progress", {})
        claimed_quests = u.get("claimed_quests", {})
        
        quest = None
        for q in DAILY_QUESTS:
            if q["id"] == quest_id:
                quest = q
                break
        
        if not quest:
            await ctx.send(embed=ce("âŒ", "> ĞšĞ²ĞµÑÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ
        progress = quest_progress.get(quest_id, 0)
        if progress < quest["goal"]:
            await ctx.send(embed=ce("âŒ", f"> ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑÑ: **{progress}/{quest['goal']}**", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ğ°
        if claimed_quests.get(quest_id, False):
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ·Ğ° ÑÑ‚Ğ¾Ñ‚ ĞºĞ²ĞµÑÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ’Ñ‹Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ
        new_coins = coins + quest["reward"]
        claimed_quests[quest_id] = True
        save_user(uid, sid, {"coins": new_coins, "claimed_quests": claimed_quests})
        
        desc = f"> {quest['emoji']} **{quest['title']}**\n"
        desc += f"> ğŸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **+{quest['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞšĞ²ĞµÑÑ‚ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ† Ğ”ĞĞ¡Ğ¢Ğ˜Ğ–Ğ•ĞĞ˜Ğ¯: ĞŸĞĞ›Ğ£Ğ§Ğ•ĞĞ˜Ğ• ĞĞĞ“Ğ ĞĞ”
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="aclaim")
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def achievement_claim(self, ctx: commands.Context, ach_id: str = None):
        """ğŸ† ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ·Ğ° Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ! aclaim [id]"""
        from economy import ACHIEVEMENTS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        claimed_ach = u.get("claimed_achievements", [])
        
        if ach_id not in ACHIEVEMENTS:
            await ctx.send(embed=ce("âŒ", "> Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if ach_id in claimed_ach:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ·Ğ° ÑÑ‚Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        ach = ACHIEVEMENTS[ach_id]
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
        unlocked = False
        if ach_id == "millionaire" and coins >= 1000000:
            unlocked = True
        elif ach_id == "farmer" and u.get("farms", {}) and len(u.get("farms", {})) >= 10:
            unlocked = True
        elif ach_id == "gambler" and u.get("casino_earnings", 0) >= 100000:
            unlocked = True
        elif ach_id == "trader" and u.get("market_trades", 0) >= 50:
            unlocked = True
        elif ach_id == "investor" and u.get("total_investments", 0) >= 500000:
            unlocked = True
        
        if not unlocked:
            await ctx.send(embed=ce("âŒ", "> Ğ­Ñ‚Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ ĞµÑ‰Ñ‘ Ğ½Ğµ Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # Ğ’Ñ‹Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ
        new_coins = coins + ach["reward"]
        claimed_ach.append(ach_id)
        save_user(uid, sid, {"coins": new_coins, "claimed_achievements": claimed_ach})
        
        desc = f"> {ach['emoji']} **{ach['title']}**\n"
        desc += f"> ğŸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **+{ach['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # â¬†ï¸ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ£Ğ ĞĞ’ĞĞ•Ğ™ Ğ˜ ĞĞŸĞ«Ğ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="level")
    async def profile_level(self, ctx: commands.Context, user: disnake.Member = None):
        """â¬†ï¸ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¸ Ğ¾Ğ¿Ñ‹Ñ‚!"""
        from economy import PLAYER_LEVELS
        
        if not user:
            user = ctx.author
        
        uid, sid = str(user.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        
        xp = u.get("xp", 0)
        coins = u.get("coins", 0)
        current_level = 1
        
        for level in sorted(PLAYER_LEVELS.keys(), reverse=True):
            if xp >= PLAYER_LEVELS[level]["xp_required"]:
                current_level = level
                break
        
        level_data = PLAYER_LEVELS.get(current_level, {})
        next_level = current_level + 5
        next_data = PLAYER_LEVELS.get(next_level, {})
        
        xp_for_next = next_data.get("xp_required", xp + 1000) if next_data else xp + 1000
        xp_progress = xp - level_data.get("xp_required", 0)
        xp_needed = xp_for_next - level_data.get("xp_required", 1000)
        bar_filled = int((xp_progress / xp_needed) * 20) if xp_needed > 0 else 20
        xp_bar = "ğŸŸ©" * bar_filled + "â¬œ" * (20 - bar_filled)
        
        desc = f"> {level_data.get('title', 'ğŸŒ± ĞĞ¾Ğ²Ğ¸Ñ‡Ğ¾Ğº')} (Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ **{current_level}**)\n"
        desc += f"> ğŸ’° Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{coins:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> ğŸ“Š ĞĞ¿Ñ‹Ñ‚: **{xp:,}**\n\n"
        desc += f"> {xp_bar}\n"
        desc += f"> Ğ”Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ {next_level}: **{max(0, xp_for_next - xp):,}** Ğ¾Ğ¿Ñ‹Ñ‚Ğ°\n"
        desc += f"> 10% Ğ±Ğ¾Ğ½ÑƒÑ Ğº Ğ·Ğ°Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°Ğ¼ Ğ·Ğ° Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ Ğ°Ñ€ÑĞµĞ½Ğ°Ğ»: **+{int(level_data.get('coin_bonus', 1.0) * 100) - 100}%**"
        
        await ctx.send(embed=ce(f"â¬†ï¸ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ {user.display_name}", desc, ctx.guild, 0x9B59B6))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ Ğ Ğ•Ğ™Ğ¢Ğ˜ĞĞ“Ğ˜ Ğ˜ ĞĞĞ“Ğ ĞĞ”Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="leaderboard1")
    async def leaderboard1(self, ctx: commands.Context, board_type: str = "wealth"):
        """ğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ¸! leaderboard [wealth/power/level]"""
        from economy import LEADERBOARD_REWARDS
        
        sid = str(ctx.guild.id)
        board_config = LEADERBOARD_REWARDS.get(board_type)
        
        if not board_config:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¸Ğ¿ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        all_users = list(db["users"].find({"server_id": sid}))
        
        if board_type == "wealth":
            all_users.sort(key=lambda u: u.get("coins", 0), reverse=True)
            field_name = "ğŸ’°"
        elif board_type == "power":
            all_users.sort(key=lambda u: u.get("guild_power", 0), reverse=True)
            field_name = "âš”ï¸"
        elif board_type == "level":
            all_users.sort(key=lambda u: u.get("xp", 0), reverse=True)
            field_name = "ğŸ“ˆ"
        
        desc = ""
        for i, u in enumerate(all_users[:10], 1):
            try:
                user = await ctx.bot.fetch_user(int(u["user_id"]))
                user_name = user.name
            except:
                user_name = "Unknown"
            
            if board_type == "wealth":
                value = u.get("coins", 0)
                emoji = "ğŸ’°"
            elif board_type == "power":
                value = u.get("guild_power", 0)
                emoji = "âš”ï¸"
            else:
                value = u.get("xp", 0)
                emoji = "ğŸ“ˆ"
            
            # ĞœĞµĞ´Ğ°Ğ»Ğ¸
            medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰" if i == 3 else f"#{i}"
            reward = board_config["places"].get(i, 0)
            
            desc += f"> {medal} **{user_name}** {emoji} **{value:,}** ({reward:,} ğŸ’°)\n"
        
        desc += f"\n> ğŸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ñ‹ Ğ²Ñ‹Ğ´Ğ°ÑÑ‚ÑÑ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ Ğ¼ĞµÑÑÑ†Ğ°!"
        
        await ctx.send(embed=ce(f"ğŸ“Š {board_config['title']}", desc, ctx.guild, 0xF39C12))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # âœ¨ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞŸĞ Ğ•Ğ¡Ğ¢Ğ˜Ğ–Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="prestige")
    async def prestige(self, ctx: commands.Context):
        """âœ¨ Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶Ğ°!"""
        from economy import PRESTIGE_BONUSES
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        current_prestige = u.get("prestige_level", 0)
        coins = u.get("coins", 0)
        
        current_data = PRESTIGE_BONUSES.get(current_prestige, {})
        next_prestige = current_prestige + 1
        next_data = PRESTIGE_BONUSES.get(next_prestige)
        
        desc = f"> Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ: {current_data.get('title', 'ğŸŒ±')} **({current_prestige})**\n"
        desc += f"> ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ: **x{current_data.get('mult', 1.0)}**\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{coins:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n\n"
        
        if next_data:
            cost = next_data.get("cost", 0)
            desc += f"> ğŸ”¼ Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ: {next_data.get('title', 'â­')}\n"
            desc += f"> Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{cost:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            if coins >= cost:
                desc += f"> âœ… ĞœĞ¾Ğ¶ĞµÑˆÑŒ Ğ¿Ğ¾Ğ²Ñ‹ÑĞ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶!"
            else:
                desc += f"> âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ **{cost - coins:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        else:
            desc += f"> ğŸ‘‘ Ğ¢Ñ‹ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶Ğ°!"
        
        await ctx.send(embed=ce("âœ¨ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ĞŸÑ€ĞµÑÑ‚Ğ¸Ğ¶Ğ°", desc, ctx.guild, 0xE74C3C))

    @commands.command(name="ppromote")
    @commands.cooldown(1, 3600, commands.BucketType.user)
    async def prestige_promote(self, ctx: commands.Context):
        """âœ¨ ĞŸĞ¾Ğ²Ñ‹ÑĞ¸Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶Ğ°!"""
        from economy import PRESTIGE_BONUSES
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        current_prestige = u.get("prestige_level", 0)
        
        next_prestige = current_prestige + 1
        next_data = PRESTIGE_BONUSES.get(next_prestige)
        
        if not next_data:
            await ctx.send(embed=ce("âŒ", "> Ğ£Ğ¶Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        cost = next_data.get("cost", 0)
        if coins < cost:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{cost:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        new_coins = coins - cost
        new_xp = 0  # ĞĞ±Ğ½ÑƒĞ»ÑĞµĞ¼ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶Ğµ
        save_user(uid, sid, {"coins": new_coins, "xp": new_xp, "prestige_level": next_prestige})
        
        desc = f"> ğŸ‰ ĞŸÑ€ĞµÑÑ‚Ğ¸Ğ¶ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½!\n"
        desc += f"> {next_data.get('title', 'â­')}\n"
        desc += f"> ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ: **x{next_data.get('mult', 1.0)}**\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚"
        
        await ctx.send(embed=ce("âœ¨ ĞŸÑ€ĞµÑÑ‚Ğ¸Ğ¶ ĞŸĞ¾Ğ²Ñ‹ÑˆĞµĞ½", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”¥ Ğ•Ğ–Ğ•Ğ”ĞĞ•Ğ’ĞĞ«Ğ• Ğ›Ğ£ĞšĞ˜ ĞœĞĞ›ĞĞ¢Ğ« (DAILY STREAKS)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="streak")
    async def daily_streak(self, ctx: commands.Context):
        """ğŸ”¥ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½ÑƒÑ ÑĞµÑ€Ğ¸Ñ!"""
        from datetime import datetime
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        
        streak = u.get("daily_streak", 0)
        last_claim = u.get("last_daily_claim", 0)
        now = datetime.utcnow().timestamp()
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº
        can_claim = (now - last_claim) > 86400  # 24 Ñ‡Ğ°ÑĞ°
        
        next_reward = 100 * (1 + streak // 5)  # +100 Ğ·Ğ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 5 Ğ´Ğ½ĞµĞ¹
        
        desc = f"> ğŸ”¥ Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ ÑĞµÑ€Ğ¸Ñ: **{streak}** Ğ´Ğ½ĞµĞ¹\n"
        desc += f"> ğŸ’° Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{next_reward:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n\n"
        
        if can_claim:
            desc += f"> âœ… Ğ¢Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑˆÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ! Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!dclaim`"
        else:
            hours_left = int((86400 - (now - last_claim)) / 3600)
            desc += f"> â³ Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹ÑÑ Ñ‡ĞµÑ€ĞµĞ· **{hours_left}** Ñ‡Ğ°ÑĞ¾Ğ²"
        
        await ctx.send(embed=ce("ğŸ”¥ Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ Ğ¡ĞµÑ€Ğ¸Ñ", desc, ctx.guild, 0xFF9800))

    @commands.command(name="dclaim")
    @commands.cooldown(1, 86400, commands.BucketType.user)
    async def daily_claim(self, ctx: commands.Context):
        """ğŸ”¥ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº!"""
        from datetime import datetime
        from economy import DAILY_STREAK_REWARDS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        streak = u.get("daily_streak", 0)
        
        # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞµÑ€Ğ¸Ñ
        new_streak = streak + 1
        reward = DAILY_STREAK_REWARDS.get(new_streak, 100)
        new_coins = coins + reward
        
        save_user(uid, sid, {
            "coins": new_coins,
            "daily_streak": new_streak,
            "last_daily_claim": datetime.utcnow().timestamp()
        })
        
        desc = f"> ğŸ ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ° Ğ·Ğ° {new_streak} Ğ´Ğ½ĞµĞ¹!\n"
        desc += f"> **+{reward:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğ¹ ĞŸĞ¾Ğ´Ğ°Ñ€Ğ¾Ğº", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¤ ĞĞ›Ğ¬Ğ¯ĞĞ¡Ğ«
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="alliance")
    async def alliance(self, ctx: commands.Context):
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        alliances = get_guild_alliances(gid)
        
        if not alliances:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ²Ğ¾Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ½Ğ¸ Ğ² ĞºĞ°ĞºĞ¾Ğ¼ Ğ°Ğ»ÑŒÑĞ½ÑĞµ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        for alliance in alliances:
            members = alliance.get("members", [])
            member_guilds = [get_guild(m) for m in members]
            member_guilds = [g for g in member_guilds if g]
            
            total_power = 0
            for guild in member_guilds:
                army = guild.get("army", {})
                power = sum(ARMY_UNITS[u]["power"] * c for u, c in army.items() if u in ARMY_UNITS)
                total_power += power
            
            desc = f"**{alliance['name']}** (Ğ›Ğ¸Ğ´ĞµÑ€: <@{alliance['leader_id']}>)\n> _ _\n"
            desc += f"> Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: **{len(member_guilds)}**\n"
            desc += f"> ĞĞ±Ñ‰Ğ°Ñ Ğ±Ğ¾ĞµĞ²Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ: **{total_power}**\n"
            desc += f"> ĞšĞ°Ğ·Ğ½Ğ° Ğ°Ğ»ÑŒÑĞ½ÑĞ°: **{alliance.get('bank', 0):,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"> _ _\n> Ğ§Ğ»ĞµĞ½Ñ‹:\n"
            
            for guild in member_guilds:
                tag = guild["tag"]
                desc += f"> â€¢ **[{tag}]** {guild['name']}\n"
            
            await ctx.send(embed=ce("ğŸ¤ ĞĞ»ÑŒÑĞ½Ñ", desc, ctx.guild, 0x9B59B6))

    @commands.command(name="createalliance")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def createalliance(self, ctx: commands.Context, alliance_name: str):
        """ğŸ¤ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ°Ğ»ÑŒÑĞ½Ñ."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        if u.get("guild_rank") != "owner":
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if get_alliance(sid, alliance_name):
            await ctx.send(embed=ce("âŒ", "> ĞĞ»ÑŒÑĞ½Ñ Ñ Ñ‚Ğ°ĞºĞ¸Ğ¼ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        alliance_id = str(uuid.uuid4())[:8]
        save_alliance(alliance_id, {
            "id": alliance_id,
            "server_id": sid,
            "name": alliance_name.lower(),
            "leader_id": uid,
            "members": [gid],
            "bank": 0,
            "created_at": str(datetime.utcnow()),
        })
        
        desc = f"> **{alliance_name}**\n"
        desc += f"> Ğ›Ğ¸Ğ´ĞµÑ€: {ctx.author.mention}\n"
        desc += f"> ĞÑĞ½Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ: [**{gd['tag']}**] {gd['name']}"
        
        await ctx.send(embed=ce("âœ… ĞĞ»ÑŒÑĞ½Ñ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½!", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="joinalliance")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def joinalliance(self, ctx: commands.Context, alliance_name: str):
        """ğŸ¤ ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ°Ğ»ÑŒÑĞ½ÑÑƒ (Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ Ğ»Ğ¸Ğ´ĞµÑ€Ğ°)."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        gd = get_guild(gid)
        if u.get("guild_rank") != "owner":
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ´ĞµÑ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        alliance = get_alliance(sid, alliance_name)
        if not alliance:
            await ctx.send(embed=ce("âŒ", f"> ĞĞ»ÑŒÑĞ½Ñ '{alliance_name}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if gid in alliance.get("members", []):
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ°Ğ»ÑŒÑĞ½ÑĞµ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        members = alliance.get("members", [])
        members.append(gid)
        save_alliance(alliance["id"], {"members": members})
        
        desc = f"> {ctx.author.mention} Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ» **[{gd['tag']}]** Ğº Ğ°Ğ»ÑŒÑĞ½ÑÑƒ **{alliance['name']}**!"
        
        await ctx.send(embed=ce("âœ… Ğ’ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² ĞĞ»ÑŒÑĞ½Ñ!", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="alliances")
    async def alliances_list(self, ctx: commands.Context):
        """ğŸ¤ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ²ÑĞµ Ğ°Ğ»ÑŒÑĞ½ÑÑ‹ ÑĞµÑ€Ğ²ĞµÑ€Ğ°."""
        sid = str(ctx.guild.id)
        
        try:
            all_alliances = list(db["alliances"].find({"server_id": sid}))
        except:
            all_alliances = []
        
        if not all_alliances:
            await ctx.send(embed=ce("âŒ", "> ĞĞ° ÑĞµÑ€Ğ²ĞµÑ€Ğµ Ğ½ĞµÑ‚ Ğ°Ğ»ÑŒÑĞ½ÑĞ¾Ğ²!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        desc = ""
        for alliance in all_alliances:
            members_count = len(alliance.get("members", []))
            desc += f"> ğŸ¤ **{alliance['name']}** ({members_count} Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹)\n"
            desc += f"  ĞšĞ°Ğ·Ğ½Ğ°: **{alliance.get('bank', 0):,}** | Ğ›Ğ¸Ğ´ĞµÑ€: <@{alliance['leader_id']}>\n\n"
        
        await ctx.send(embed=ce("ğŸ¤ ĞĞ»ÑŒÑĞ½ÑÑ‹ Ğ¡ĞµÑ€Ğ²ĞµÑ€Ğ°", desc, ctx.guild, 0x9B59B6))

    @commands.command(name="galliancepay")
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def galliancepay(self, ctx: commands.Context, amount: int):
        """ğŸ¤ ĞŸĞ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´ĞµĞ½ÑŒĞ³Ğ¸ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ°Ğ»ÑŒÑĞ½ÑĞ°."""
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        gid = u.get("guild_id")
        
        if not gid:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ² Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        alliances = get_guild_alliances(gid)
        if not alliances:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ğ²Ğ¾Ñ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ½Ğµ ÑĞ¾ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ² Ğ°Ğ»ÑŒÑĞ½ÑĞµ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if coins < amount:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{amount:,}**, Ğ° Ñƒ Ñ‚ĞµĞ±Ñ **{coins:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        alliance = alliances[0]
        new_bank = alliance.get("bank", 0) + amount
        save_alliance(alliance["id"], {"bank": new_bank})
        save_user(uid, sid, {"coins": coins - amount})
        
        desc = f"> {ctx.author.mention} Ğ¿Ğ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ğ» **{amount:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ°Ğ»ÑŒÑĞ½ÑĞ°!\n"
        desc += f"> ĞšĞ°Ğ·Ğ½Ğ°: **{new_bank:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{coins - amount:,}**"
        
        await ctx.send(embed=ce("ğŸ¤ ĞŸĞ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² ĞĞ»ÑŒÑĞ½Ñ", desc, ctx.guild, 0x2ECC71))

    # â”€â”€ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @commands.command(name="ghelp")
    async def ghelp(self, ctx: commands.Context):
        sid     = str(ctx.guild.id)
        msg_req = get_msg_required(sid)
        e = disnake.Embed(title="ğŸŒ¸ Sunshine Paradise â€” ĞŸĞĞ›ĞĞĞ¯ Ğ¡ĞŸĞ ĞĞ’ĞšĞ v5.2", color=0xFF69B4)
        e.set_author(name=EMBED_AUTHOR, icon_url=ctx.guild.icon.url if ctx.guild.icon else None)
        
        e.add_field(name="ğŸ’° Ğ­ĞšĞĞĞĞœĞ˜ĞšĞ Ğ˜Ğ“Ğ ĞĞšĞĞ’",
                    value=("`!profile [@]` `!balance` `!daily` `!work [job]`\n"
                           "`!pay @ÑĞ·ĞµÑ€ ÑÑƒĞ¼Ğ¼Ğ°` `!top` `!level [@]`"),
                    inline=False)
        
        e.add_field(name="ğŸ° ĞšĞĞ—Ğ˜ĞĞ â€” 6 Ğ˜Ğ“Ğ  (Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸ all/half/25%)",
                    value=("`!blackjack [ÑÑ‚Ğ°Ğ²ĞºĞ°]` Ğ¸Ğ»Ğ¸ `!bj all/half/25%/Ñ‡Ğ¸ÑĞ»Ğ¾` â€” **Ğ‘Ğ»ÑĞºĞ´Ğ¶ĞµĞº**\n"
                           "`!slots [ÑÑ‚Ğ°Ğ²ĞºĞ°]` â€” **Ğ¡Ğ»Ğ¾Ñ‚Ñ‹** (3x, 2x, 1x)\n"
                           "`!coinflip [ÑÑ‚Ğ°Ğ²ĞºĞ°] [heads/tails/h/t]` â€” **ĞœĞ¾Ğ½ĞµÑ‚ĞºĞ°**\n"
                           "`!roulette [ÑÑ‚Ğ°Ğ²ĞºĞ°] [red/black/Ñ‡Ğ¸ÑĞ»Ğ¾]` â€” **Ğ ÑƒĞ»ĞµÑ‚ĞºĞ°**\n"
                           "`!dice [ÑÑ‚Ğ°Ğ²ĞºĞ°]` â€” **ĞšÑƒĞ±Ğ¸ĞºĞ¸** 1-100\n"
                           "`!wheel [ÑÑ‚Ğ°Ğ²ĞºĞ°]` â€” **ĞšĞ¾Ğ»ĞµÑĞ¾ Ğ¤Ğ¾Ñ€Ñ‚ÑƒĞ½Ñ‹** (x50!)"),
                    inline=False)
        
        e.add_field(name="ğŸ° Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜ â€” ĞŸĞĞ›ĞĞĞ• Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•",
                    value=(f"`!gcreate [Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ]` _(Ğ½ÑƒĞ¶Ğ½Ğ¾ {msg_req} msg)_ â€” Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ\n"
                           "`!ginfo [Ñ‚ĞµĞ³]` `!glist` `!gmembers`\n"
                           "`!ginvite @ÑĞ·ĞµÑ€` `!gleave` `!gdelete`"),
                    inline=False)
        
        e.add_field(name="ğŸ’¸ ĞšĞĞ—ĞĞ Ğ˜ Ğ‘ĞĞĞš Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜",
                    value=("`!gbank` â€” Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ĞºĞ°Ğ·Ğ½Ñ‹\n"
                           "`!gdeposit ÑÑƒĞ¼Ğ¼Ğ°` â€” ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ°Ğ·Ğ½Ñƒ\n"
                           "`!gwithdraw ÑÑƒĞ¼Ğ¼Ğ°` â€” Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ğ¸Ğ· ĞºĞ°Ğ·Ğ½Ñ‹\n"
                           "`!geconomy` â€” ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"),
                    inline=False)
        
        e.add_field(name="âš™ï¸ Ğ’Ğ›ĞĞ¡Ğ¢Ğ¬ Ğ˜ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•",
                    value=("`!gkick @ÑĞ·ĞµÑ€` â€” Ğ˜ÑĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ\n"
                           "`!gpromote @ÑĞ·ĞµÑ€` â€” ĞŸĞ¾Ğ²Ñ‹ÑĞ¸Ñ‚ÑŒ Ğ² Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ\n"
                           "`!gdemote @ÑĞ·ĞµÑ€` â€” ĞŸĞ¾Ğ½Ğ¸Ğ·Ğ¸Ñ‚ÑŒ Ğ² Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ\n"
                           "`!gtransfer @ÑĞ·ĞµÑ€` â€” ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ Ğ»Ğ¸Ğ´ĞµÑ€ÑÑ‚Ğ²Ğ¾"),
                    inline=False)
        
        e.add_field(name="ğŸ¨ Ğ”ĞĞŸ. Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ•Ğ™",
                    value=("`!gcolor Ñ†Ğ²ĞµÑ‚` â€” Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ†Ğ²ĞµÑ‚\n"
                           "`!gdesc Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ` â€” Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ\n"
                           "`!granks` â€” Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ€Ğ°Ğ½Ğ³Ğ¾Ğ²\n"
                           "`!gstats` â€” Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"),
                    inline=False)
        
        e.add_field(name="âš”ï¸ Ğ’ĞĞ™ĞĞ« Ğ˜ ĞšĞĞĞ¤Ğ›Ğ˜ĞšĞ¢Ğ«",
                    value=("`!gwar @Ñ‚ĞµĞ³` â€” **Ğ’Ğ¾Ğ¹Ğ½Ğ° Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¹** Ñ Ğ±Ğ¾ĞµĞ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¾Ğ¹\n"
                           "`!gpatrol` â€” ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸\n"
                           "`!army` â€” Ğ¡Ğ¾ÑÑ‚Ğ°Ğ² Ğ°Ñ€Ğ¼Ğ¸Ğ¸\n"
                           "`!recruit [Ñ‚Ğ¸Ğ¿] [ĞºĞ¾Ğ»]` â€” ĞĞ°Ğ½ÑÑ‚ÑŒ Ğ²Ğ¾Ğ¹ÑĞº"),
                    inline=False)
        
        e.add_field(name="ğŸŒ¾ Ğ¤Ğ•Ğ ĞœĞ« Ğ˜ ĞŸĞĞ¡Ğ¡Ğ˜Ğ’ĞĞ«Ğ™ Ğ”ĞĞ¥ĞĞ”",
                    value=("`!buyfarm [Ñ‚Ğ¸Ğ¿]` â€” ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ¼Ñƒ\n"
                           "`!myfarms` â€” ĞœĞ¾Ğ¸Ñ‹ Ñ„ĞµÑ€Ğ¼Ñ‹\n"
                           "`!harvest` â€” Ğ¡Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ¶Ğ°Ğ¹\n"
                           "`!gmyincome` â€” Ğ”Ğ¾Ñ…Ğ¾Ğ´ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"),
                    inline=False)
        
        e.add_field(name="ğŸ“Š Ğ Ğ«ĞĞĞš Ğ˜ Ğ˜ĞĞ’Ğ•Ğ¡Ğ¢Ğ˜Ğ¦Ğ˜Ğ˜",
                    value=("`!market` â€” Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ñ‚Ğ¾Ğ²Ğ°Ñ€Ñ‹\n"
                           "`!invest [Ğ¿Ğ»Ğ°Ğ½] [ÑÑƒĞ¼Ğ¼Ğ°]` â€” Ğ˜Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ\n"
                           "`!invests` â€” ĞœĞ¾Ğ¸ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ğ¸\n"
                           "`!iwithdraw [id]` â€” Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸"),
                    inline=False)
        
        e.add_field(name="ğŸŠ ĞšĞ’Ğ•Ğ¡Ğ¢Ğ« Ğ˜ Ğ”ĞĞ¡Ğ¢Ğ˜Ğ–Ğ•ĞĞ˜Ğ¯",
                    value=("`!quests` â€” Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ñ‹Ğµ ĞºĞ²ĞµÑÑ‚Ñ‹\n"
                           "`!qclaim [id]` â€” ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ ĞºĞ²ĞµÑÑ‚Ğ°\n"
                           "`!achievements` â€” Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ\n"
                           "`!aclaim [id]` â€” ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ·Ğ° Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ"),
                    inline=False)
        
        e.add_field(name="ğŸ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞŸĞ Ğ•Ğ”ĞœĞ•Ğ¢ĞĞ’",
                    value=("`!inventory` â€” Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ²\n"
                           "`!sellitem [id]` â€” ĞŸÑ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚\n"
                           "`!mybadge` â€” ĞœĞ¾Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ°Ñ„Ñ„Ğ°"),
                    inline=False)
        
        e.add_field(name="ğŸ“ˆ ĞŸĞ ĞĞ“Ğ Ğ•Ğ¡Ğ¡Ğ˜Ğ¯",
                    value=("`!prestige` â€” Ğ˜Ğ½Ñ„Ğ¾ Ğ¾ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶Ğµ\n"
                           "`!ppromote` â€” ĞŸĞ¾Ğ²Ñ‹ÑĞ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµÑÑ‚Ğ¸Ğ¶\n"
                           "`!streak` â€” Ğ•Ğ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ°Ñ ÑĞµÑ€Ğ¸Ñ\n"
                           "`!dclaim` â€” ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ°Ñ€Ğ¾Ğº Ğ´Ğ½Ñ"),
                    inline=False)
        
        e.add_field(name="ğŸ”¬ Ğ¢Ğ•Ğ¥ĞĞĞ›ĞĞ“Ğ˜Ğ˜",
                    value=("`!tech` â€” Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¹\n"
                           "`!buytech [Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ]` â€” ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ"),
                    inline=False)
        
        e.add_field(name="ğŸ¤ ĞĞ›Ğ¬Ğ¯ĞĞ¡Ğ«",
                    value=("`!createalliance [Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ]` â€” Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑĞ½Ñ\n"
                           "`!joinalliance [Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ]` â€” ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ\n"
                           "`!alliance` â€” Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ°Ğ»ÑŒÑĞ½ÑĞ°\n"
                           "`!alliances` â€” Ğ’ÑĞµ Ğ°Ğ»ÑŒÑĞ½ÑÑ‹"),
                    inline=False)
        
        e.add_field(name="ï¿½ ĞœĞĞ©Ğ¬ Ğ˜ Ğ Ğ•Ğ™Ğ¢Ğ˜ĞĞ“Ğ˜ Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ™",
                    value=("`!glist` â€” **Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ¼Ğ¾Ñ‰Ğ¸** (ĞºĞ°Ğ·Ğ½Ğ°+Ñ‡Ğ»ĞµĞ½Ñ‹+Ğ¿Ğ¾Ğ±ĞµĞ´Ñ‹+Ğ°Ğ¿Ğ³Ñ€ĞµĞ¹Ğ´Ñ‹)\n"
                           "`!gstats [Ñ‚ĞµĞ³]` â€” **ĞŸĞ¾Ğ»Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°** Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸\n"
                           "`!gcard [Ñ‚ĞµĞ³]` â€” **Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ°** Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸\n"
                           "`!granking [power|wins|members|bank]` â€” **Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³** Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸ÑĞ¼\n"
                           "`!gtop` â€” **Ğ¢ĞĞŸ 3** Ğ»ÑƒÑ‡ÑˆĞ¸Ğµ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸"),
                    inline=False)
        
        e.add_field(name="ğŸ’ ĞŸĞĞ”Ğ”Ğ•Ğ Ğ–ĞšĞ Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜",
                    value=("`!gtribute [ÑÑƒĞ¼Ğ¼Ğ°]` â€” **ĞŸĞ¾Ğ¶ĞµÑ€Ñ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ** Ğ´ĞµĞ½ĞµĞ³ Ğ² ĞºĞ°Ğ·Ğ½Ñƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ (1 Ñ€Ğ°Ğ· Ğ² Ñ‡Ğ°Ñ)"),
                    inline=False)
        
        e.add_field(name="ğŸ“ˆ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ£Ğ ĞĞ’ĞĞ•Ğ™ Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ™",
                    value=("`!glevel [Ñ‚ĞµĞ³]` â€” **Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ¸ Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ** Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸\n"
                           "`!glevels` â€” **Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ** ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ Ğ¸ Ğ±Ğ¾Ğ½ÑƒÑĞ¾Ğ²"),
                    inline=False)
        
        e.add_field(name="ï¿½ğŸ® ĞŸĞ Ğ˜ĞœĞ•Ğ Ğ« ĞšĞĞœĞĞĞ”",
                    value=("`!bj all` â€” ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¼Ğ¾Ğ½ĞµÑ‚Ñ‹\n"
                           "`!bj half` â€” ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ñƒ\n"
                           "`!bj 25%` â€” ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ 25% Ğ¾Ñ‚ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°\n"
                           "`!BJ 1000` â€” ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ 1000 (Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ğ½Ğµ Ğ²Ğ°Ğ¶ĞµĞ½)\n"
                           "`!GAY` = `!gay` = `!gAy` (Ğ»ÑĞ±Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹)"),
                    inline=False)
        
        clr_line = " ".join(f"`{k}`" for k in COLORS)
        e.add_field(name="ğŸ¨ Ğ¦Ğ’Ğ•Ğ¢Ğ Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ˜", value=clr_line, inline=False)
        e.set_footer(text=f"ğŸŒ¸ Sunshine Paradise | Ğ’ÑĞµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğµ! | ĞÑƒĞ¶Ğ½Ğ¾ {msg_req} ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ğŸ’¬")
        await ctx.send(embed=e)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞŸĞ Ğ•Ğ”ĞœĞ•Ğ¢ĞĞ’ Ğ˜ Ğ›Ğ£Ğ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="inventory")
    async def player_inventory(self, ctx: commands.Context, user: disnake.Member = None):
        """ğŸ’ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ²!"""
        from economy import EQUIPMENT_ITEMS, EQUIPMENT_TIERS
        
        if not user:
            user = ctx.author
        
        uid, sid = str(user.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        equipment = u.get("equipment", {})
        
        if not equipment:
            await ctx.send(embed=ce("âŒ", "> Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¿ÑƒÑÑ‚!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        desc = ""
        total_power = 0
        for item_id, tier in equipment.items():
            if item_id in EQUIPMENT_ITEMS:
                item = EQUIPMENT_ITEMS[item_id]
                tier_data = EQUIPMENT_TIERS.get(tier, {})
                stats = tier_data.get("stats", {})
                power = stats.get("power", 1)
                total_power += power
                desc += f"> {tier_data.get('rarity', '?')} {item['name']} (+{power} Ğ¼Ğ¾Ñ‰Ğ¸)\n"
        
        desc += f"\n> âš”ï¸ ĞĞ±Ñ‰Ğ°Ñ Ğ¼Ğ¾Ñ‰ÑŒ: **+{total_power}**"
        await ctx.send(embed=ce("ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ", desc, ctx.guild, 0x9B59B6))

    @commands.command(name="sellitem")
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def sell_item(self, ctx: commands.Context, item_id: str = None):
        """ğŸ ĞŸÑ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚! sellitem [item_id]"""
        from economy import EQUIPMENT_ITEMS, EQUIPMENT_TIERS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        equipment = u.get("equipment", {})
        
        if not item_id or item_id not in equipment:
            await ctx.send(embed=ce("âŒ", "> ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        tier = equipment[item_id]
        item = EQUIPMENT_ITEMS.get(item_id, {})
        tier_data = EQUIPMENT_TIERS.get(tier, {})
        
        # Ğ¦ĞµĞ½Ğ° Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ñ€ĞµĞ´ĞºĞ¾ÑÑ‚Ğ¸
        base_price = item.get("sell_price", 100)
        multiplier = {"common": 1, "rare": 3, "epic": 8, "legendary": 25, "mythic": 100}
        sell_price = base_price * multiplier.get(tier, 1)
        
        new_coins = coins + sell_price
        del equipment[item_id]
        save_user(uid, sid, {"coins": new_coins, "equipment": equipment})
        
        desc = f"> {tier_data.get('rarity', '?')} {item.get('name', 'ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚')}\n"
        desc += f"> ğŸ’° **+{sell_price:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞŸÑ€Ğ¾Ğ´Ğ°Ğ¶Ğ° ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ğ°", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞĞ¥ĞĞ¢Ğ« (BOUNTIES)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="bounties")
    async def bounties(self, ctx: commands.Context):
        """ğŸ¯ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¾Ñ…Ğ¾Ñ‚Ñ‹ (bounties)!"""
        from economy import BOUNTY_TYPES
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        active_bounties = u.get("active_bounties", [])
        
        desc = ""
        for bounty_type, bounty_data in BOUNTY_TYPES.items():
            is_active = bounty_type in active_bounties
            status = "âœ… ĞĞšĞ¢Ğ˜Ğ’ĞĞ" if is_active else "âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°"
            desc += f"> {bounty_data['title']} ({status})\n"
            desc += f"  Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: {bounty_data['difficulty']}\n"
            desc += f"  ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{bounty_data['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"  Ğ’Ñ€ĞµĞ¼Ñ: {bounty_data['timer']} ÑĞµĞº\n\n"
        
        desc += "> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!acceptbounty [Ñ‚Ğ¸Ğ¿]` Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ñ Ğ¾Ñ…Ğ¾Ñ‚Ñ‹!"
        await ctx.send(embed=ce("ğŸ¯ ĞÑ…Ğ¾Ñ‚Ñ‹ Ğ¡ĞµÑ€Ğ²ĞµÑ€Ğ°", desc, ctx.guild, 0xE74C3C))

    @commands.command(name="acceptbounty")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def accept_bounty(self, ctx: commands.Context, bounty_type: str = None):
        """ğŸ¯ ĞŸÑ€Ğ¸Ğ½ÑÑ‚ÑŒ Ğ¾Ñ…Ğ¾Ñ‚Ñƒ! acceptbounty [Ñ‚Ğ¸Ğ¿]"""
        from economy import BOUNTY_TYPES
        from datetime import datetime
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        active_bounties = u.get("active_bounties", [])
        
        if bounty_type not in BOUNTY_TYPES:
            await ctx.send(embed=ce("âŒ", "> ĞÑ…Ğ¾Ñ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        if bounty_type in active_bounties:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑĞ» ÑÑ‚Ñƒ Ğ¾Ñ…Ğ¾Ñ‚Ñƒ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        bounty = BOUNTY_TYPES[bounty_type]
        active_bounties.append(bounty_type)
        
        save_user(uid, sid, {
            "active_bounties": active_bounties,
            f"bounty_{bounty_type}_start": datetime.utcnow().timestamp()
        })
        
        desc = f"> {bounty['title']}\n"
        desc += f"> Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: **{bounty['difficulty']}**\n"
        desc += f"> ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{bounty['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ’Ñ€ĞµĞ¼Ñ: **{bounty['timer']}** ÑĞµĞº\n\n"
        desc += f"> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!completebounty {bounty_type}` Ğ´Ğ»Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ!"
        
        await ctx.send(embed=ce("âœ… ĞÑ…Ğ¾Ñ‚Ğ° ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ°", desc, ctx.guild, 0x2ECC71))

    @commands.command(name="completebounty")
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def complete_bounty(self, ctx: commands.Context, bounty_type: str = None):
        """ğŸ¯ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ¾Ñ…Ğ¾Ñ‚Ñƒ (ĞµÑĞ»Ğ¸ Ğ²Ñ€ĞµĞ¼Ñ Ğ²Ñ‹ÑˆĞ»Ğ¾)!"""
        from economy import BOUNTY_TYPES
        from datetime import datetime
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        active_bounties = u.get("active_bounties", [])
        
        if bounty_type not in active_bounties:
            await ctx.send(embed=ce("âŒ", "> Ğ¢Ñ‹ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑĞ» ÑÑ‚Ñƒ Ğ¾Ñ…Ğ¾Ñ‚Ñƒ!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        bounty = BOUNTY_TYPES[bounty_type]
        start_time = u.get(f"bounty_{bounty_type}_start", 0)
        now = datetime.utcnow().timestamp()
        elapsed = now - start_time
        
        if elapsed < bounty["timer"]:
            minutes_left = int((bounty["timer"] - elapsed) / 60)
            await ctx.send(embed=ce("â³", f"> ĞÑ…Ğ¾Ñ‚Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ° ĞµÑ‰Ñ‘ **{minutes_left}** Ğ¼Ğ¸Ğ½ÑƒÑ‚!", ctx.guild, 0xFF8800), delete_after=10)
            return
        
        # Ğ’Ñ‹Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ
        new_coins = coins + bounty["reward"]
        active_bounties.remove(bounty_type)
        save_user(uid, sid, {
            "coins": new_coins,
            "active_bounties": active_bounties,
            f"bounty_{bounty_type}_completed": True
        })
        
        desc = f"> {bounty['title']} Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!\n"
        desc += f"> ğŸ’° **+{bounty['reward']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞÑ…Ğ¾Ñ‚Ğ° Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ”¨ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞšĞ ĞĞ¤Ğ¢Ğ
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="crafting")
    async def crafting(self, ctx: commands.Context):
        """ğŸ”¨ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ñ€ĞµÑ†ĞµĞ¿Ñ‚Ñ‹ ĞºÑ€Ğ°Ñ„Ñ‚Ğ°!"""
        from economy import CRAFTING_RECIPES, MARKET_GOODS
        
        desc = ""
        for recipe_id, recipe in CRAFTING_RECIPES.items():
            ingredients_str = ", ".join([
                f"{MARKET_GOODS.get(ing, {}).get('emoji', '?')} x{qty}"
                for ing, qty in recipe["ingredients"].items()
            ])
            desc += f"> **{recipe['name']}**\n"
            desc += f"  Ğ˜Ğ½Ğ³Ñ€ĞµĞ´Ğ¸ĞµĞ½Ñ‚Ñ‹: {ingredients_str}\n"
            desc += f"  Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **{recipe['coin_cost']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"  â­ XP: **+{recipe['xp_reward']}**\n\n"
        
        desc += "> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!craft [Ñ€ĞµÑ†ĞµĞ¿Ñ‚]` Ğ´Ğ»Ñ ĞºÑ€Ğ°Ñ„Ñ‚Ğ°!"
        await ctx.send(embed=ce("ğŸ”¨ Ğ ĞµÑ†ĞµĞ¿Ñ‚Ñ‹ ĞšÑ€Ğ°Ñ„Ñ‚Ğ°", desc, ctx.guild, 0x8B4513))

    @commands.command(name="craft")
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def craft_item(self, ctx: commands.Context, recipe_id: str = None):
        """ğŸ”¨ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚! craft [recipe_id]"""
        from economy import CRAFTING_RECIPES, MARKET_GOODS
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        u = get_user(uid, sid)
        coins = u.get("coins", 0)
        market_inv = u.get("market_inventory", {})
        xp = u.get("xp", 0)
        
        if recipe_id not in CRAFTING_RECIPES:
            await ctx.send(embed=ce("âŒ", "> Ğ ĞµÑ†ĞµĞ¿Ñ‚ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        recipe = CRAFTING_RECIPES[recipe_id]
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¼Ğ¾Ğ½ĞµÑ‚Ñ‹
        if coins < recipe["coin_cost"]:
            await ctx.send(embed=ce("âŒ ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ¼Ğ¾Ğ½ĞµÑ‚",
                                     f"> ĞÑƒĞ¶Ğ½Ğ¾ **{recipe['coin_cost']:,}**",
                                     ctx.guild, 0xFF0000), delete_after=10)
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸Ğ½Ğ³Ñ€ĞµĞ´Ğ¸ĞµĞ½Ñ‚Ñ‹
        for ingredient, qty_needed in recipe["ingredients"].items():
            if market_inv.get(ingredient, 0) < qty_needed:
                await ctx.send(embed=ce("âŒ", f"> ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ **{ingredient}** (Ğ½ÑƒĞ¶Ğ½Ğ¾ {qty_needed})", ctx.guild, 0xFF0000), delete_after=10)
                return
        
        # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ ĞºÑ€Ğ°Ñ„Ñ‚
        new_coins = coins - recipe["coin_cost"]
        new_xp = xp + recipe["xp_reward"]
        
        for ingredient, qty_needed in recipe["ingredients"].items():
            market_inv[ingredient] -= qty_needed
        
        save_user(uid, sid, {
            "coins": new_coins,
            "xp": new_xp,
            "market_inventory": market_inv
        })
        
        desc = f"> âœ¨ {recipe['name']}\n"
        desc += f"> Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!\n"
        desc += f"> ğŸ’° Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ: **-{recipe['coin_cost']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
        desc += f"> â­ XP: **+{recipe['xp_reward']}**\n"
        desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
        
        await ctx.send(embed=ce("âœ… ĞšÑ€Ğ°Ñ„Ñ‚ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½", desc, ctx.guild, 0x2ECC71))

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ‘¹ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ Ğ•Ğ™Ğ”ĞĞ’ (GUILD RAIDS/BOSSES)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @commands.command(name="raid")
    async def guild_raid(self, ctx: commands.Context):
        """ğŸ‘¹ Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ€ĞµĞ¹Ğ´Ğ°Ñ… Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸!"""
        from economy import RAID_BOSSES
        
        gid = str(ctx.guild.id)
        g = get_guild(gid)
        
        raid_progress = g.get("raid_progress", {})
        
        desc = ""
        for boss_id, boss in RAID_BOSSES.items():
            progress = raid_progress.get(boss_id, {"health": 0, "participants": 0})
            health_pct = max(0, int((progress.get("health", boss["health"]) / boss["health"]) * 100))
            
            health_bar = "ğŸŸ¥" * (health_pct // 10) + "â¬›" * (10 - (health_pct // 10))
            
            desc += f"> {boss['name']} (Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ {boss['level']})\n"
            desc += f"> HP: {health_bar} **{health_pct}%**\n"
            desc += f"> Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: **{progress.get('participants', 0)}**\n"
            desc += f"> ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **{boss['rewards_per_player']:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚/ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºÑƒ\n\n"
        
        desc += "> Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹ `!raidattack [boss_id]` Ğ´Ğ»Ñ Ğ°Ñ‚Ğ°ĞºĞ¸!"
        await ctx.send(embed=ce("ğŸ‘¹ Ğ ĞµĞ¹Ğ´Ñ‹ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸", desc, ctx.guild, 0x8B0000))

    @commands.command(name="raidattack")
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def raid_attack(self, ctx: commands.Context, boss_id: str = None):
        """ğŸ‘¹ ĞÑ‚Ğ°ĞºĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾ÑÑĞ° Ñ€ĞµĞ¹Ğ´Ğ°! raidattack [boss_id]"""
        from economy import RAID_BOSSES
        import random
        
        uid, sid = str(ctx.author.id), str(ctx.guild.id)
        gid = str(ctx.guild.id)
        u = get_user(uid, sid)
        g = get_guild(gid)
        
        if boss_id not in RAID_BOSSES:
            await ctx.send(embed=ce("âŒ", "> Ğ‘Ğ¾ÑÑ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=10)
            return
        
        boss = RAID_BOSSES[boss_id]
        user_power = sum(ARMY_UNITS[un]["power"] * ct for un, ct in u.get("army", {}).items() if un in ARMY_UNITS)
        tech_bonus = sum(TECHNOLOGIES[t].get("power_bonus", 0) for t in u.get("technologies", []) if t in TECHNOLOGIES)
        total_power = user_power + tech_bonus
        
        # Ğ£Ñ€Ğ¾Ğ½ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹
        damage = random.randint(int(total_power * 0.5), int(total_power * 1.5))
        
        raid_progress = g.get("raid_progress", {})
        boss_progress = raid_progress.get(boss_id, {"health": boss["health"], "participants": 0})
        
        new_health = max(0, boss_progress.get("health", boss["health"]) - damage)
        boss_progress["health"] = new_health
        boss_progress["participants"] = boss_progress.get("participants", 0) + 1
        raid_progress[boss_id] = boss_progress
        
        save_guild(gid, {"raid_progress": raid_progress})
        
        defeated = new_health <= 0
        
        if defeated:
            # Ğ Ğ°Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñƒ Ğ²ÑĞµĞ¼ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°Ğ¼
            reward = boss["rewards_per_player"]
            participants = boss_progress["participants"]
            total_reward = reward * participants
            
            new_coins = u.get("coins", 0) + reward
            save_user(uid, sid, {"coins": new_coins})
            
            desc = f"> ğŸ‰ **{boss['name']}** ĞŸĞĞ‘Ğ•Ğ–Ğ”Ğ•Ğ!\n"
            desc += f"> Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: **{participants}**\n"
            desc += f"> ĞĞ°Ğ³Ñ€Ğ°Ğ´Ğ°: **+{reward:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"> ğŸ’° Ğ˜Ñ‚Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ´Ğ°Ğ½Ğ¾: **{total_reward:,}** Ğ¼Ğ¾Ğ½ĞµÑ‚\n"
            desc += f"> Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: **{new_coins:,}**"
            
            # Ğ¡Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ±Ğ¾ÑÑĞ°
            boss_progress = {"health": boss["health"], "participants": 0}
            raid_progress[boss_id] = boss_progress
            save_guild(gid, {"raid_progress": raid_progress})
        else:
            desc = f"> âš”ï¸ ĞÑ‚Ğ°ĞºĞ° Ğ¿Ğ¾ **{boss['name']}**\n"
            desc += f"> Ğ£Ñ€Ğ¾Ğ½: **-{damage}** HP\n"
            desc += f"> ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: **{new_health:,}/{boss['health']:,}** HP\n"
            desc += f"> Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²: **{boss_progress['participants']}**"
        
        await ctx.send(embed=ce("ğŸ‘¹ ĞÑ‚Ğ°ĞºĞ° Ğ½Ğ° Ğ‘Ğ¾ÑÑĞ°", desc, ctx.guild, 0xFF6347 if defeated else 0xFFA500))

    # â”€â”€ ĞÑˆĞ¸Ğ±ĞºĞ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @commands.Cog.listener()
    async def on_member_join(self, member: disnake.Member):
        """ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ğ½Ğ° Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ¼ ÑĞµÑ€Ğ²ĞµÑ€Ğµ."""
        global _member_badge_cache
        
        if member.guild.id != HOME_SERVER_ID or member.bot:
            return
        
        try:
            # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ
            badge_level = await check_member_profile(member)
            now = datetime.utcnow().timestamp()
            _member_badge_cache[member.id] = (badge_level,
                MEMBER_BADGES.get(badge_level, {}).get("multiplier", 1.0),
                now)
            
            # ĞŸÑ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°ÑÑ‚ Ñ€Ğ¾Ğ»ÑŒ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ±Ğ°Ñ„Ñ„
            if badge_level and badge_level in MEMBER_BADGES:
                role_id = MEMBER_BADGES[badge_level].get("role_id")
                if role_id:
                    role = member.guild.get_role(role_id)
                    if role:
                        await member.add_roles(role, reason=f"ĞĞ²Ñ‚Ğ¾Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ±Ğ°Ñ„Ñ„Ğ°: {badge_level}")
                        
        except Exception as e:
            print(f"[on_member_join] ĞÑˆĞ¸Ğ±ĞºĞ° Ğ´Ğ»Ñ {member.id}: {e}")

    @commands.Cog.listener()
    async def on_command_error(self, ctx: commands.Context, error):
        if hasattr(ctx.command, "on_error") or ctx.cog is not self:
            return
        if isinstance(error, commands.CommandOnCooldown):
            await ctx.send(embed=ce("â° ĞšÑƒĞ»Ğ´Ğ°ÑƒĞ½",
                                     f"> Ğ–Ğ´Ğ¸ **{error.retry_after:.0f} ÑĞµĞº**!", ctx.guild, 0xFF8800),
                           delete_after=5)
        elif isinstance(error, commands.CheckFailure):
            await ctx.send(embed=ce("âŒ", "> Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=5)
        elif isinstance(error, commands.MemberNotFound):
            await ctx.send(embed=ce("âŒ", "> ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!", ctx.guild, 0xFF0000), delete_after=5)
        elif isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(embed=ce("âŒ", f"> ĞĞµ Ñ…Ğ²Ğ°Ñ‚Ğ°ĞµÑ‚ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ°!\n> `!ghelp`", ctx.guild, 0xFF0000),
                           delete_after=8)
        elif isinstance(error, commands.CommandNotFound):
            pass
        else:
            print(f"[ERR] {ctx.command}: {error}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ Ğ“Ğ•ĞĞ•Ğ ĞĞ¢ĞĞ  ĞšĞĞ Ğ¢Ğ˜ĞĞĞš Ğ“Ğ˜Ğ›Ğ¬Ğ”Ğ˜Ğ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def create_guild_card(gd: dict, sid: str, guild: disnake.Guild = None) -> bytes:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºÑ€Ğ°ÑĞ¸Ğ²ÑƒÑ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ³Ğ¸Ğ»ÑŒĞ´Ğ¸Ğ¸ Ñ PIL"""
    from PIL import Image, ImageDraw, ImageFont
    import io
    
    try:
        # Ğ Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹
        W, H = 800, 600
        img = Image.new('RGB', (W, H), color=(15, 15, 30))  # Ğ¢Ñ‘Ğ¼Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ğ½
        draw = ImageDraw.Draw(img)
        
        # Ğ“Ñ€Ğ°Ğ´Ğ¸ĞµĞ½Ñ‚-Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ñ‹Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚ (Ñ€Ğ°Ğ¼ĞºĞ°)
        guild_color = COLORS.get(gd.get("color"), DEFAULT_COLOR)
        hex_color = f"#{guild_color:06X}"
        
        # Ğ Ğ¸ÑÑƒĞµĞ¼ ĞºÑ€Ğ°ÑĞ¸Ğ²ÑƒÑ Ñ€Ğ°Ğ¼ĞºÑƒ
        for i in range(5):
            draw.rectangle([i, i, W-i-1, H-i-1], outline=hex_color, width=1)
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        cnt = member_count(gd["id"], sid)
        lim = member_limit(gd.get("upgrades", []))
        pwr = calc_guild_power(gd, sid)
        wins = gd.get("wins", 0)
        losses = gd.get("losses", 0)
        bank = gd.get("bank", 0)
        upgrades = len(gd.get("upgrades", []))
        level, xp, xp_needed = calc_guild_level(gd, sid)
        
        # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹
        try:
            title_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 60)
            header_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 28)
            text_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 22)
            small_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 18)
        except:
            title_font = ImageFont.load_default()
            header_font = ImageFont.load_default()
            text_font = ImageFont.load_default()
            small_font = ImageFont.load_default()
        
        # Ğ—ĞĞ“ĞĞ›ĞĞ’ĞĞš - Ğ¢ĞµĞ³ Ğ¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ
        tag_text = f"[{gd['tag']}]"
        name_text = gd['name'][:25]
        
        draw.text((W//2, 40), tag_text, fill=(100, 200, 255), font=header_font, anchor="mm")
        draw.text((W//2, 90), name_text, fill=(255, 200, 100), font=title_font, anchor="mm")
        
        # Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ
        draw.line([(50, 130), (W-50, 130)], fill=guild_color, width=2)
        
        # Ğ›Ğ•Ğ’ĞĞ¯ ĞšĞĞ›ĞĞĞšĞ
        left_x, top_y = 60, 150
        draw.text((left_x, top_y), "ğŸ“Š Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ", fill=(100, 255, 200), font=header_font)
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ ÑĞ²ĞµÑ€Ñ…Ñƒ
        draw.text((W-100, top_y), f"ğŸ“ˆ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ {level}", fill=(255, 200, 100), font=header_font, anchor="ra")
        
        stats_y = top_y + 45
        stats = [
            (f"ğŸ’ª ĞœĞ¾Ñ‰ÑŒ: {pwr:,}", (100, 200, 255)),
            (f"ğŸ’° ĞšĞ°Ğ·Ğ½Ğ°: {bank:,}", (255, 215, 100)),
            (f"ğŸ‘¥ Ğ§Ğ»ĞµĞ½Ñ‹: {cnt}/{lim}", (150, 255, 150)),
        ]
        
        for stat, color in stats:
            draw.text((left_x, stats_y), stat, fill=color, font=text_font)
            stats_y += 35
        
        # ĞŸĞ ĞĞ’ĞĞ¯ ĞšĞĞ›ĞĞĞšĞ
        right_x = W // 2 + 30
        draw.text((right_x, top_y), "ğŸ† Ğ‘ĞĞ•Ğ’ĞĞ¯ Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ", fill=(255, 100, 150), font=header_font)
        
        battle_y = top_y + 45
        battles = [
            (f"ğŸ¥‡ ĞŸĞ¾Ğ±ĞµĞ´: {wins}", (100, 255, 100)),
            (f"â˜ ï¸ ĞŸĞ¾Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹: {losses}", (255, 100, 100)),
            (f"ğŸ”§ ĞĞ¿Ğ³Ñ€ĞµĞ¹Ğ´Ğ¾Ğ²: {upgrades}", (200, 150, 255)),
        ]
        
        for battle, color in battles:
            draw.text((right_x, battle_y), battle, fill=color, font=text_font)
            battle_y += 35
        
        # Ğ Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ 2
        draw.line([(50, 300), (W-50, 300)], fill=guild_color, width=2)
        
        # ĞĞ˜Ğ–ĞĞ¯Ğ¯ Ğ¡Ğ•ĞšĞ¦Ğ˜Ğ¯ - ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¸ Ğ›Ğ¸Ğ´ĞµÑ€
        desc_y = 320
        draw.text((W//2, desc_y), "Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯", fill=(200, 200, 200), font=header_font, anchor="mm")
        
        desc = gd.get("description", "ğŸŒ¸ Ğ“Ğ¸Ğ»ÑŒĞ´Ğ¸Ñ Ğ±ĞµĞ· Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ")[:50] + "..."
        draw.text((W//2, desc_y + 50), f'"{desc}"', fill=(180, 180, 200), font=small_font, anchor="mm")
        
        # Ğ›Ğ¸Ğ´ĞµÑ€
        leader_id = gd.get("owner_id", "unknown")
        leader_text = f"ğŸ‘‘ Ğ›Ğ¸Ğ´ĞµÑ€: ID {leader_id}"
        draw.text((W//2, desc_y + 100), leader_text, fill=(255, 215, 0), font=small_font, anchor="mm")
        
        # ĞĞ¸Ğ¶Ğ½Ğ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚
        draw.text((W//2, H-35), "ğŸŒ¸ Sunshine Paradise", fill=(200, 100, 200), font=small_font, anchor="mm")
        
        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² BytesIO
        img_buffer = io.BytesIO()
        img.save(img_buffer, format='PNG')
        img_buffer.seek(0)
        
        return img_buffer.getvalue()
    
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸: {e}")
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”Œ ĞŸĞĞ”ĞšĞ›Ğ®Ğ§Ğ•ĞĞ˜Ğ•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup(bot: commands.Bot):
    init_db()
    bot.add_cog(GuildCog(bot))
    # CasinoCog ÑƒĞ¶Ğµ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½ Ğ² GuildCog, Ğ½Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹
    print("âœ… Sunshine Paradise â€” Guilds v4.1 Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½!")
    print(f"   ğŸ—„ï¸ MongoDB | ğŸ¨ Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²: {len(COLORS)} | â±ï¸ Rate-limit Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°")
    print("âœ… ĞšĞ°Ğ·Ğ¸Ğ½Ğ¾ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹!")